"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocEnum = exports.DocEnumMember = exports.DocInterface = exports.DocMethodSignature = exports.DocPropertySignature = exports.DocClass = exports.DocMethod = exports.DocConstructor = exports.DocProperty = exports.DocFunction = exports.DocType = exports.DocVariable = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const JSDocs_1 = require("./JSDocs");
const typescript_1 = __importDefault(require("typescript"));
const os_1 = require("os");
/**
 * @private
 */
class DocVariable extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Variable', 'Variables'); }
    getName(item, sf) {
        return item.name.getText(sf);
    }
    filterItem(item) {
        const items = [];
        if (typescript_1.default.isVariableStatement(item) && item.modifiers &&
            (this.sup.nothingPrivate || item.modifiers.some(m => m.kind === typescript_1.default.SyntaxKind.ExportKeyword))) {
            for (const v of item.declarationList.declarations) {
                items.push(v);
            }
        }
        return items;
    }
}
exports.DocVariable = DocVariable;
/**
 * @private
 */
class DocType extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Type', 'Types'); }
    getName(item) {
        return item.name.text;
    }
    filterItem(item) {
        if (typescript_1.default.isTypeAliasDeclaration(item) &&
            (this.sup.nothingPrivate || this.isExportedDeclaration(item)))
            return [item];
        return [];
    }
}
exports.DocType = DocType;
/**
 * @private
 */
class DocFunction extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Function', 'Functions', 'Details'); }
    getName(item) {
        var _a;
        return ((_a = item.name) === null || _a === void 0 ? void 0 : _a.text) || '';
    }
    filterItem(item) {
        if (typescript_1.default.isFunctionDeclaration(item) && this.isNotPrivate(item) &&
            (this.sup.nothingPrivate || this.isExportedDeclaration(item))) {
            return [item];
        }
        return [];
    }
    toMarkDownTs(docItem) {
        const n = docItem.item;
        const sf = docItem.sf;
        const printer = this.sup.printer;
        let mdts = printer.printNode(typescript_1.default.EmitHint.Unspecified, n, sf);
        if (n.body && !docItem.jsDoc.publicBody) {
            // Remove the function body
            const bodyts = printer.printNode(typescript_1.default.EmitHint.Unspecified, n.body, sf);
            mdts = this.removeTs(mdts, bodyts);
        }
        return mdts;
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        md += this.returnsDetails(docItem);
        md += this.argumentsDetails(docItem);
        md += this.throwsDetails(docItem);
        return md;
    }
}
exports.DocFunction = DocFunction;
/**
 * @private
 */
class DocProperty extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Property', 'Properties'); }
    getName(item) {
        if (typescript_1.default.isIdentifier(item.name))
            return item.name.text;
        return '';
    }
    filterItem(item) {
        if (typescript_1.default.isPropertyDeclaration(item) && this.isNotPrivate(item))
            return [item];
        return [];
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        md += this.examplesDetails(docItem);
        const comments = this.commentsDetails(docItem);
        if (md || comments) {
            const mdts = this.toTsMarkDown(docItem, mdLinks, true);
            let intro = `${this.sup.headingLevelMd(4)} Property ${docItem.name}${os_1.EOL}${os_1.EOL}`;
            if (comments)
                intro += comments;
            md = `${intro}${mdts}${os_1.EOL}${md}`;
        }
        return md;
    }
}
exports.DocProperty = DocProperty;
/**
 * @private
 */
class DocConstructor extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Constructor', 'Constructors', 'Arguments'); }
    getName(item) {
        return 'constructor';
    }
    filterItem(item) {
        if (typescript_1.default.isConstructorDeclaration(item) && this.isNotPrivate(item))
            return [item];
        return [];
    }
    toMarkDownTs(docItem) {
        const n = docItem.item;
        const sf = docItem.sf;
        const printer = this.sup.printer;
        let mdts = printer.printNode(typescript_1.default.EmitHint.Unspecified, n, sf);
        if (n['body'] && !(this.sup.nothingPrivate || docItem.jsDoc.publicBody)) {
            // Remove the body from documentation typescript
            const bodyts = printer.printNode(typescript_1.default.EmitHint.Unspecified, n['body'], sf);
            mdts = this.removeTs(mdts, bodyts);
        }
        return mdts;
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        md += this.argumentsDetails(docItem);
        md += this.throwsDetails(docItem);
        md += this.examplesDetails(docItem);
        const comments = this.commentsDetails(docItem);
        if (md || comments) {
            const mdts = this.toTsMarkDown(docItem, mdLinks, true);
            let intro = `${this.sup.headingLevelMd(4)} Constructor${os_1.EOL}${os_1.EOL}`;
            if (comments)
                intro += comments;
            md = `${intro}${mdts}${os_1.EOL}${md}`;
        }
        return md;
    }
}
exports.DocConstructor = DocConstructor;
/**
 * @private
 */
class DocMethod extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Method', 'Methods'); }
    getName(item) {
        if (typescript_1.default.isIdentifier(item.name))
            return item.name.text;
        return '';
    }
    filterItem(item) {
        if (typescript_1.default.isMethodDeclaration(item) && this.isNotPrivate(item))
            return [item];
        return [];
    }
    toMarkDownTs(docItem) {
        const n = docItem.item;
        const sf = docItem.sf;
        const printer = this.sup.printer;
        let mdts = printer.printNode(typescript_1.default.EmitHint.Unspecified, n, sf);
        if (n['body'] && !(this.sup.nothingPrivate || docItem.jsDoc.publicBody)) {
            // Remove the body from documentation typescript
            const bodyts = printer.printNode(typescript_1.default.EmitHint.Unspecified, n['body'], sf);
            mdts = this.removeTs(mdts, bodyts);
        }
        return mdts;
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        md += this.returnsDetails(docItem);
        md += this.argumentsDetails(docItem);
        md += this.throwsDetails(docItem);
        md += this.examplesDetails(docItem);
        const comments = this.commentsDetails(docItem);
        if (md || comments) {
            const mdts = this.toTsMarkDown(docItem, mdLinks, true);
            let intro = `${this.sup.headingLevelMd(4)} Method ${docItem.name}${os_1.EOL}${os_1.EOL}`;
            if (comments)
                intro += comments;
            md = `${intro}${mdts}${os_1.EOL}${md}`;
        }
        return md;
    }
}
exports.DocMethod = DocMethod;
/**
 * @private
 */
class DocClass extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Class', 'Classes'); }
    getName(item) {
        var _a;
        return ((_a = item.name) === null || _a === void 0 ? void 0 : _a.text) || '';
    }
    filterItem(item) {
        if (typescript_1.default.isClassDeclaration(item) &&
            (this.sup.nothingPrivate || this.isExportedDeclaration(item)))
            return [item];
        return [];
    }
    extractMemberDocs(docItem) {
        const n = docItem.item;
        const sf = docItem.sf;
        let docs = [
            new DocConstructor(this.sup),
            new DocProperty(this.sup),
            new DocMethod(this.sup),
        ];
        for (const ce of n.members) {
            for (const doc of docs) {
                doc.tryAddItem(ce, sf, docItem);
            }
        }
        // Eliminate empty doc categories
        docs = docs.filter(d => d.docItems.length > 0);
        return docs;
    }
    toMarkDownTs(docItem) {
        const n = docItem.item;
        const sf = docItem.sf;
        const printer = this.sup.printer;
        // class definition typescript including all members and function bodies...
        let mdts = printer.printNode(typescript_1.default.EmitHint.Unspecified, n, sf);
        for (const ce of n.members) {
            const r = (0, JSDocs_1.getJsDocInfo)(ce, docItem.name);
            let isPrivate = false;
            if (!this.sup.nothingPrivate &&
                ((ce['modifiers'] && ce['modifiers'].some(m => m.kind === typescript_1.default.SyntaxKind.PrivateKeyword)) ||
                    r.tags.some(t => typescript_1.default.isJSDocPrivateTag(t)))) {
                isPrivate = true;
                // Remove entire member
                const memberts = printer.printNode(typescript_1.default.EmitHint.Unspecified, ce, sf);
                mdts = this.removeTs(mdts, memberts, true);
            }
            else if (ce['body'] && !r.publicBody) {
                // Remove the body from documentation typescript
                const bodyts = printer.printNode(typescript_1.default.EmitHint.Unspecified, ce['body'], sf);
                mdts = this.removeTs(mdts, bodyts);
            }
            else if (ce['initializer'] && r.privateInitializer) {
                const initializerts = printer.printNode(typescript_1.default.EmitHint.Unspecified, ce['initializer'], sf);
                mdts = this.removeTs(mdts, `= ${initializerts};`);
            }
        }
        return mdts;
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        for (const doc of docItem.memberDocs) {
            for (const item of doc.docItems) {
                const details = doc.toMarkDownDetails(item, mdLinks);
                if (details)
                    md += details;
            }
        }
        return md;
    }
}
exports.DocClass = DocClass;
/**
 * @private
 */
class DocPropertySignature extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Property', 'Properties'); }
    getName(item) {
        if (typescript_1.default.isIdentifier(item.name))
            return item.name.text;
        return '';
    }
    filterItem(item) {
        if (typescript_1.default.isPropertySignature(item) && this.isNotPrivate(item))
            return [item];
        return [];
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        md += this.examplesDetails(docItem);
        const comments = this.commentsDetails(docItem);
        if (md || comments) {
            const mdts = this.toTsMarkDown(docItem, mdLinks, true);
            let intro = `${this.sup.headingLevelMd(4)} Property ${docItem.name}${os_1.EOL}${os_1.EOL}`;
            if (comments)
                intro += comments;
            md = `${intro}${mdts}${os_1.EOL}${md}`;
        }
        return md;
    }
}
exports.DocPropertySignature = DocPropertySignature;
/**
 * @private
 */
class DocMethodSignature extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Method', 'Methods'); }
    getName(item) {
        if (typescript_1.default.isIdentifier(item.name))
            return item.name.text;
        return '';
    }
    filterItem(item) {
        if (typescript_1.default.isMethodSignature(item) && this.isNotPrivate(item))
            return [item];
        return [];
    }
    toMarkDownTs(docItem) {
        const n = docItem.item;
        const sf = docItem.sf;
        const printer = this.sup.printer;
        let mdts = printer.printNode(typescript_1.default.EmitHint.Unspecified, n, sf);
        if (n['body'] && !(this.sup.nothingPrivate || docItem.jsDoc.publicBody)) {
            // Remove the body from documentation typescript
            const bodyts = printer.printNode(typescript_1.default.EmitHint.Unspecified, n['body'], sf);
            mdts = this.removeTs(mdts, bodyts);
        }
        return mdts;
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        md += this.returnsDetails(docItem);
        md += this.argumentsDetails(docItem);
        md += this.throwsDetails(docItem);
        md += this.examplesDetails(docItem);
        const comments = this.commentsDetails(docItem);
        if (md || comments) {
            const mdts = this.toTsMarkDown(docItem, mdLinks, true);
            let intro = `${this.sup.headingLevelMd(4)} Method ${docItem.name}${os_1.EOL}${os_1.EOL}`;
            if (comments)
                intro += comments;
            md = `${intro}${mdts}${os_1.EOL}${md}`;
        }
        return md;
    }
}
exports.DocMethodSignature = DocMethodSignature;
/**
 * @private
 */
class DocInterface extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Interface', 'Interfaces'); }
    getName(item) {
        return item.name.text;
    }
    filterItem(item) {
        if (typescript_1.default.isInterfaceDeclaration(item) &&
            (this.sup.nothingPrivate || this.isExportedDeclaration(item)))
            return [item];
        return [];
    }
    extractMemberDocs(docItem) {
        const n = docItem.item;
        const sf = docItem.sf;
        let docs = [
            new DocPropertySignature(this.sup),
            new DocMethodSignature(this.sup),
        ];
        for (const ce of n.members) {
            for (const doc of docs) {
                doc.tryAddItem(ce, sf, docItem);
            }
        }
        // Eliminate empty doc categories
        docs = docs.filter(d => d.docItems.length > 0);
        return docs;
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        for (const doc of docItem.memberDocs) {
            for (const item of doc.docItems) {
                const details = doc.toMarkDownDetails(item, mdLinks);
                if (details)
                    md += details;
            }
        }
        return md;
    }
}
exports.DocInterface = DocInterface;
/**
 * @private
 */
class DocEnumMember extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Member', 'Members'); }
    getName(item) {
        if (typescript_1.default.isIdentifier(item.name))
            return item.name.text;
        return '';
    }
    filterItem(item) {
        if (typescript_1.default.isEnumMember(item) && this.isNotPrivate(item))
            return [item];
        return [];
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        md += this.examplesDetails(docItem);
        const comments = this.commentsDetails(docItem);
        if (md || comments) {
            const mdts = this.toTsMarkDown(docItem, mdLinks, true);
            let intro = `${this.sup.headingLevelMd(4)} Member ${docItem.name}${os_1.EOL}${os_1.EOL}`;
            if (comments)
                intro += comments;
            md = `${intro}${mdts}${os_1.EOL}${md}`;
        }
        return md;
    }
}
exports.DocEnumMember = DocEnumMember;
/**
 * @private
 */
class DocEnum extends JSDocs_1.DocBase {
    constructor(sup) { super(sup, 'Enum', 'Enums'); }
    getName(item) {
        return item.name.text;
    }
    filterItem(item) {
        if (typescript_1.default.isEnumDeclaration(item) &&
            (this.sup.nothingPrivate || this.isExportedDeclaration(item)))
            return [item];
        return [];
    }
    extractMemberDocs(docItem) {
        const n = docItem.item;
        const sf = docItem.sf;
        let docs = [
            new DocEnumMember(this.sup)
        ];
        for (const ce of n.members) {
            for (const doc of docs) {
                doc.tryAddItem(ce, sf, docItem);
            }
        }
        // Eliminate empty doc categories
        docs = docs.filter(d => d.docItems.length > 0);
        return docs;
    }
    toMarkDownDetails(docItem, mdLinks) {
        let md = '';
        for (const doc of docItem.memberDocs) {
            for (const item of doc.docItems) {
                const details = doc.toMarkDownDetails(item, mdLinks);
                if (details)
                    md += details;
            }
        }
        return md;
    }
}
exports.DocEnum = DocEnum;
//# sourceMappingURL=Docs.js.map