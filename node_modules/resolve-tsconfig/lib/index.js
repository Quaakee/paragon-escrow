"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createDiagnostic: () => createDiagnostic,
  findConfigFile: () => findConfigFile,
  normalizePathSeparator: () => normalizePathSeparator,
  resolveTsConfig: () => resolveTsConfig
});
module.exports = __toCommonJS(src_exports);

// src/create-diagnostic.ts
var import_typescript = __toESM(require("typescript"), 1);
function createDiagnostic(message) {
  let file = message.file;
  if (typeof file === "string") {
    file = import_typescript.default.createSourceFile(file, import_typescript.default.sys.readFile(file) ?? "", import_typescript.default.ScriptTarget.ESNext);
  }
  return {
    messageText: message.messageText,
    code: message.code === void 0 ? -0 : message.code,
    category: message.category ?? import_typescript.default.DiagnosticCategory.Error,
    file,
    start: message.start ?? void 0,
    length: message.length ?? void 0
  };
}

// src/find-config-file.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_node_path2 = __toESM(require("path"), 1);
var import_typescript2 = __toESM(require("typescript"), 1);

// src/find-file-up.ts
var import_node_path = __toESM(require("path"), 1);
function findFileUp(directory, stopDirectory, callback) {
  const result = callback(directory);
  if (result !== void 0) {
    return result;
  }
  if (directory === stopDirectory) {
    return void 0;
  }
  const parentPath = import_node_path.default.dirname(directory);
  if (parentPath === directory) {
    return void 0;
  }
  return findFileUp(parentPath, stopDirectory, callback);
}

// src/normalize-path-separator.ts
function normalizePathSeparator(path4) {
  return path4.replace(/[/\\]+/g, "/");
}

// src/find-config-file.ts
function normalizeOptions(options) {
  const absolutePath = normalizePathSeparator(import_node_path2.default.resolve(options.startDirectory ?? process.cwd(), options.filePath));
  const startDirectory = import_node_path2.default.dirname(absolutePath);
  if (options.startDirectory && import_node_path2.default.isAbsolute(options.filePath)) {
    const providedStartDirectory = normalizePathSeparator(import_node_path2.default.resolve(options.startDirectory));
    if (startDirectory !== providedStartDirectory) {
      return {
        diagnostics: [
          createDiagnostic({
            code: -100,
            messageText: `Do not specify the 'startDirectory' option if you give an absolute 'filePath' or they must be equal. Expected '${startDirectory}', received '${providedStartDirectory}'.`
          })
        ]
      };
    }
  }
  if (options.startDirectoryShouldExists && !import_node_fs.default.existsSync(startDirectory)) {
    return {
      diagnostics: [
        createDiagnostic({
          code: 6148,
          messageText: `Directory '${startDirectory}' does not exist, skipping all lookups in it.`
        })
      ]
    };
  }
  return {
    normalizedOptions: {
      fileName: import_node_path2.default.basename(absolutePath),
      startDirectory,
      startDirectoryShouldExists: Boolean(options.startDirectoryShouldExists),
      stopDirectory: options.stopDirectory ? normalizePathSeparator(import_node_path2.default.resolve(options.stopDirectory)) : void 0
    }
  };
}
function findConfigFile(options) {
  const { diagnostics: diagnostic, normalizedOptions } = normalizeOptions(options);
  if (diagnostic) {
    return { diagnostics: diagnostic };
  }
  const { startDirectory, stopDirectory, fileName } = normalizedOptions;
  const configFilePath = findFileUp(startDirectory, stopDirectory, (directory) => {
    const filePath = `${directory}/${fileName}`;
    return import_typescript2.default.sys.fileExists(filePath) ? filePath : void 0;
  });
  if (configFilePath) {
    return { configFilePath };
  }
  return {
    diagnostics: [
      createDiagnostic({
        code: 5081,
        messageText: `Cannot find a '${fileName}' file at the current directory: '${startDirectory}'.`
      })
    ]
  };
}

// src/resolve-ts-config.ts
var import_typescript3 = __toESM(require("typescript"), 1);
var import_node_path3 = __toESM(require("path"), 1);
function resolveTsConfig(options) {
  const filePath = (options == null ? void 0 : options.filePath) ?? "tsconfig.json";
  const { diagnostics, configFilePath } = findConfigFile({ ...options, filePath });
  if (diagnostics) {
    return { diagnostics };
  }
  const jsonText = import_typescript3.default.sys.readFile(configFilePath);
  if (!jsonText) {
    return {
      diagnostics: [
        createDiagnostic({ code: 5083, file: configFilePath, messageText: `Cannot read file '${configFilePath}'.` })
      ]
    };
  }
  const configObject = import_typescript3.default.parseConfigFileTextToJson(configFilePath, jsonText);
  if (configObject.error) {
    return { diagnostics: [configObject.error] };
  }
  const parsedCommandLine = import_typescript3.default.parseJsonConfigFileContent(
    configObject.config,
    import_typescript3.default.sys,
    import_node_path3.default.dirname(configFilePath),
    void 0,
    configFilePath
  );
  if (parsedCommandLine.errors.length > 0) {
    return { diagnostics: parsedCommandLine.errors };
  }
  return { config: parsedCommandLine };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createDiagnostic,
  findConfigFile,
  normalizePathSeparator,
  resolveTsConfig
});
//# sourceMappingURL=index.js.map