"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha1 = exports.toBuildInsTypes = exports.checkByteStringLiteral = exports.allowByteStringLiteral = exports.findBuildChangeOutputExpression = exports.findInsertCodeSeparatorStatement = exports.findReturnStatement = exports.alterFileExt = exports.isNumberLiteralExpr = exports.hasModifier = exports.number2hex = exports.getBuiltInType = exports.getPreimage = exports.signTx = void 0;
const crypto_1 = require("crypto");
const path_1 = __importDefault(require("path"));
const scryptlib_1 = require("scryptlib");
const typescript_1 = __importStar(require("typescript"));
var scryptlib_2 = require("scryptlib");
Object.defineProperty(exports, "signTx", { enumerable: true, get: function () { return scryptlib_2.signTx; } });
Object.defineProperty(exports, "getPreimage", { enumerable: true, get: function () { return scryptlib_2.getPreimage; } });
function getBuiltInType(type) {
    switch (type) {
        case "bigint":
        case "number":
            return "int";
        case "boolean":
            return "bool";
        case "PubKeyHash":
            return "Ripemd160";
        case "string":
            return "bytes";
        case "PubKey":
        case "Sig":
        case "Ripemd160":
        case "Sha256":
        case "Sha1":
        case "SigHashType":
        case "SigHashPreimage":
        case "OpCodeType":
        case "auto":
        case "PrivKey":
            return type;
        default:
            return "";
    }
}
exports.getBuiltInType = getBuiltInType;
function number2hex(val) {
    let hex = val.toString(16);
    if (hex.length % 2 === 1) {
        hex = '0' + hex;
    }
    return hex;
}
exports.number2hex = number2hex;
function hasModifier(node, ...kinds) {
    if (typescript_1.default.canHaveModifiers(node)) {
        let modifiers = typescript_1.default.getModifiers(node);
        if (typeof modifiers === 'undefined') {
            return false;
        }
        for (const modifier of modifiers)
            if (kinds.includes(modifier.kind))
                return true;
    }
    return false;
}
exports.hasModifier = hasModifier;
function isNumberLiteralExpr(expr) {
    if (expr === undefined)
        return false;
    if (typescript_1.default.isNumericLiteral(expr) || typescript_1.default.isBigIntLiteral(expr)) {
        return true;
    }
    return false;
}
exports.isNumberLiteralExpr = isNumberLiteralExpr;
function alterFileExt(filename, toExt, fromExt) {
    const originalExt = fromExt || path_1.default.extname(filename);
    const extReg = new RegExp(`${originalExt}$`);
    return filename.replace(extReg, '.' + toExt);
}
exports.alterFileExt = alterFileExt;
function findReturnStatement(node) {
    let res = undefined;
    function visit(node) {
        if (res) {
            return;
        }
        if (typescript_1.default.isReturnStatement(node)) {
            res = node;
            return;
        }
        typescript_1.default.forEachChild(node, visit);
    }
    visit(node);
    return res;
}
exports.findReturnStatement = findReturnStatement;
function findInsertCodeSeparatorStatement(node) {
    let res = undefined;
    function visit(node) {
        if (res) {
            return;
        }
        if (typescript_1.default.isExpressionStatement(node) && typescript_1.default.isCallExpression(node.expression)) {
            if (node.expression.getText() === "this.insertCodeSeparator()") {
                res = node;
                return;
            }
        }
        typescript_1.default.forEachChild(node, visit);
    }
    visit(node);
    return res;
}
exports.findInsertCodeSeparatorStatement = findInsertCodeSeparatorStatement;
function findBuildChangeOutputExpression(node) {
    let res = undefined;
    function visit(node) {
        if (res) {
            return;
        }
        if ((0, typescript_1.isPropertyAccessExpression)(node)) {
            const expr = node;
            const name = expr.name.getText();
            if (name === 'buildChangeOutput') {
                res = expr;
                return;
            }
        }
        typescript_1.default.forEachChild(node, visit);
    }
    visit(node);
    return res;
}
exports.findBuildChangeOutputExpression = findBuildChangeOutputExpression;
function allowByteStringLiteral(node) {
    if (typescript_1.default.isCallExpression(node)) {
        if ((0, scryptlib_1.isSubBytes)(node.expression.getText())
            || node.expression.getText() == "PubKeyHash"
            || node.expression.getText() == "Addr"
            || node.expression.getText() === "toByteString") {
            return true;
        }
    }
    return false;
}
exports.allowByteStringLiteral = allowByteStringLiteral;
function checkByteStringLiteral(node) {
    let text = node.getText();
    text = text.substring(1, text.length - 1); //remove ' or ";
    let parent = node.parent;
    const fn = parent.expression.getText();
    switch (fn) {
        case scryptlib_1.ScryptType.PUBKEY: {
            const pubkey = (0, scryptlib_1.getValidatedHexString)(text, true);
            if (pubkey.length > 0 && pubkey.length / 2 != 33) {
                throw new Error("invalid PubKey length, expect a ByteString with 33 bytes");
            }
            break;
        }
        case "PubKeyHash":
        case "Addr":
        case scryptlib_1.ScryptType.RIPEMD160: {
            const pkh = (0, scryptlib_1.getValidatedHexString)(text, true);
            if (pkh.length > 0 && pkh.length / 2 != 20) {
                throw new Error(`invalid ${fn} length, expect a ByteString with 20 bytes`);
            }
            break;
        }
        case scryptlib_1.ScryptType.SHA1: {
            const sha1 = (0, scryptlib_1.getValidatedHexString)(text, true);
            if (sha1.length > 0 && sha1.length / 2 != 20) {
                throw new Error(`invalid ${fn} length, expect a ByteString with 20 bytes`);
            }
            break;
        }
        case scryptlib_1.ScryptType.SHA256: {
            const sha256 = (0, scryptlib_1.getValidatedHexString)(text, true);
            if (sha256.length > 0 && sha256.length / 2 != 32) {
                throw new Error(`invalid ${fn} length, expect a ByteString with 32 bytes`);
            }
            break;
        }
        case scryptlib_1.ScryptType.OPCODETYPE: {
            const sighash = (0, scryptlib_1.getValidatedHexString)(text, true);
            if (sighash.length / 2 != 1) {
                throw new Error(`invalid ${fn} length, expect a OpCodeType with 1 bytes`);
            }
            break;
        }
        case scryptlib_1.ScryptType.SIGHASHPREIMAGE: {
            (0, scryptlib_1.getValidatedHexString)(text, false);
            break;
        }
        case scryptlib_1.ScryptType.SIG: {
            const sig = (0, scryptlib_1.getValidatedHexString)(text, true);
            if (sig.length > 0 && ![71, 72, 73].includes(sig.length / 2)) {
                throw new Error(`invalid ${fn} length, expect a Sig with (71 || 72 || 73) bytes`);
            }
        }
        default:
    }
}
exports.checkByteStringLiteral = checkByteStringLiteral;
function toBuildInsTypes(t) {
    switch (t) {
        case "ByteString":
            return "bytes";
        case "Int":
            return "int";
        case "Bool":
            return scryptlib_1.ScryptType.BOOL;
        case "Addr":
            return scryptlib_1.ScryptType.RIPEMD160;
        case "PubKey":
            return scryptlib_1.ScryptType.PUBKEY;
        case "Sig":
            return scryptlib_1.ScryptType.SIG;
        case "Ripemd160":
            return scryptlib_1.ScryptType.RIPEMD160;
        case "PubKeyHash":
            return scryptlib_1.ScryptType.RIPEMD160;
        case "Sha1":
            return scryptlib_1.ScryptType.SHA1;
        case "Sha256":
            return scryptlib_1.ScryptType.SHA256;
        case "SigHashType":
            return scryptlib_1.ScryptType.SIGHASHTYPE;
        case "SigHashPreimage":
            return scryptlib_1.ScryptType.SIGHASHPREIMAGE;
        case "OpCodeType":
            return scryptlib_1.ScryptType.OPCODETYPE;
        default:
            return undefined;
    }
}
exports.toBuildInsTypes = toBuildInsTypes;
function sha1(s) {
    const sha1 = (0, crypto_1.createHash)('sha1');
    return sha1.update(s).digest('hex');
}
exports.sha1 = sha1;
//# sourceMappingURL=utils.js.map