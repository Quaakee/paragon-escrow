// src/create-diagnostic.ts
import ts from "typescript";
function createDiagnostic(message) {
  let file = message.file;
  if (typeof file === "string") {
    file = ts.createSourceFile(file, ts.sys.readFile(file) ?? "", ts.ScriptTarget.ESNext);
  }
  return {
    messageText: message.messageText,
    code: message.code === void 0 ? -0 : message.code,
    category: message.category ?? ts.DiagnosticCategory.Error,
    file,
    start: message.start ?? void 0,
    length: message.length ?? void 0
  };
}

// src/find-config-file.ts
import fs from "node:fs";
import path2 from "node:path";
import ts2 from "typescript";

// src/find-file-up.ts
import path from "node:path";
function findFileUp(directory, stopDirectory, callback) {
  const result = callback(directory);
  if (result !== void 0) {
    return result;
  }
  if (directory === stopDirectory) {
    return void 0;
  }
  const parentPath = path.dirname(directory);
  if (parentPath === directory) {
    return void 0;
  }
  return findFileUp(parentPath, stopDirectory, callback);
}

// src/normalize-path-separator.ts
function normalizePathSeparator(path4) {
  return path4.replace(/[/\\]+/g, "/");
}

// src/find-config-file.ts
function normalizeOptions(options) {
  const absolutePath = normalizePathSeparator(path2.resolve(options.startDirectory ?? process.cwd(), options.filePath));
  const startDirectory = path2.dirname(absolutePath);
  if (options.startDirectory && path2.isAbsolute(options.filePath)) {
    const providedStartDirectory = normalizePathSeparator(path2.resolve(options.startDirectory));
    if (startDirectory !== providedStartDirectory) {
      return {
        diagnostics: [
          createDiagnostic({
            code: -100,
            messageText: `Do not specify the 'startDirectory' option if you give an absolute 'filePath' or they must be equal. Expected '${startDirectory}', received '${providedStartDirectory}'.`
          })
        ]
      };
    }
  }
  if (options.startDirectoryShouldExists && !fs.existsSync(startDirectory)) {
    return {
      diagnostics: [
        createDiagnostic({
          code: 6148,
          messageText: `Directory '${startDirectory}' does not exist, skipping all lookups in it.`
        })
      ]
    };
  }
  return {
    normalizedOptions: {
      fileName: path2.basename(absolutePath),
      startDirectory,
      startDirectoryShouldExists: Boolean(options.startDirectoryShouldExists),
      stopDirectory: options.stopDirectory ? normalizePathSeparator(path2.resolve(options.stopDirectory)) : void 0
    }
  };
}
function findConfigFile(options) {
  const { diagnostics: diagnostic, normalizedOptions } = normalizeOptions(options);
  if (diagnostic) {
    return { diagnostics: diagnostic };
  }
  const { startDirectory, stopDirectory, fileName } = normalizedOptions;
  const configFilePath = findFileUp(startDirectory, stopDirectory, (directory) => {
    const filePath = `${directory}/${fileName}`;
    return ts2.sys.fileExists(filePath) ? filePath : void 0;
  });
  if (configFilePath) {
    return { configFilePath };
  }
  return {
    diagnostics: [
      createDiagnostic({
        code: 5081,
        messageText: `Cannot find a '${fileName}' file at the current directory: '${startDirectory}'.`
      })
    ]
  };
}

// src/resolve-ts-config.ts
import ts3 from "typescript";
import path3 from "node:path";
function resolveTsConfig(options) {
  const filePath = (options == null ? void 0 : options.filePath) ?? "tsconfig.json";
  const { diagnostics, configFilePath } = findConfigFile({ ...options, filePath });
  if (diagnostics) {
    return { diagnostics };
  }
  const jsonText = ts3.sys.readFile(configFilePath);
  if (!jsonText) {
    return {
      diagnostics: [
        createDiagnostic({ code: 5083, file: configFilePath, messageText: `Cannot read file '${configFilePath}'.` })
      ]
    };
  }
  const configObject = ts3.parseConfigFileTextToJson(configFilePath, jsonText);
  if (configObject.error) {
    return { diagnostics: [configObject.error] };
  }
  const parsedCommandLine = ts3.parseJsonConfigFileContent(
    configObject.config,
    ts3.sys,
    path3.dirname(configFilePath),
    void 0,
    configFilePath
  );
  if (parsedCommandLine.errors.length > 0) {
    return { diagnostics: parsedCommandLine.errors };
  }
  return { config: parsedCommandLine };
}
export {
  createDiagnostic,
  findConfigFile,
  normalizePathSeparator,
  resolveTsConfig
};
//# sourceMappingURL=index.js.map