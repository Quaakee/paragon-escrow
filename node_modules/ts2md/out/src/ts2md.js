#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ts2md = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const TypescriptToMarkdown_1 = require("./TypescriptToMarkdown");
/**
 * Generate Typescript documentation and merge into README.md
 *
 * Attempts to validate options, constructs an instance of Ts2Md with those options, and runs the generation method.
 *
 * 1. Function argument is used if provided.
 *
 * 2. Looks for `./ts2md.json`
 *
 * 3. Default options.
 *
 * Default options are:
 *
 * ```json
 * {
 *   "inputFilename": "./src/index.ts",
 *   "outputFilename": "./apiDoc.md",
 *   "firstHeadingLevel": 2,
 *   "noTitle": true,
 *   "outputReplace": true,
 *   "readmeMerge": true
 * }
 * ```
 *
 * 4. Finally examines command line arguments which are treated as overrides of the options determined
 * by steps 1, 2, 3. Command line arguments can be provided as either:
 *
 * ```
 * --inputFilename ../index.ts
 * ```
 *
 * or
 *
 * ```
 * --inputFilename=../index.ts
 * ```
 *
 * @param options Optional options to control markdown generation.
 * @publicbody
 */
function ts2md(options) {
    if (!options) {
        try {
            const configPath = path.resolve('./ts2md.json');
            const json = fs.readFileSync(configPath, { encoding: 'utf8' });
            options = JSON.parse(json);
        }
        catch ( /* */_a) { /* */ }
    }
    if (!(options === null || options === void 0 ? void 0 : options.options)) {
        options || (options = {
            inputFilename: './src/index.ts',
            outputFilename: '',
            firstHeadingLevel: 2,
            noTitle: true,
            readmeMerge: true,
            noDetailsSummary: false
            //nothingPrivate: true
        });
        const args = process.argv;
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (!arg.startsWith('--'))
                continue;
            const e = arg.indexOf('=');
            let a = '', v = '';
            if (e > -1) {
                a = arg.slice(2, e);
                v = arg.slice(e + 1);
            }
            else {
                a = arg.slice(2);
                v = args[++i];
            }
            switch (a) {
                case 'inputFilename':
                    options.inputFilename = v;
                    break;
                case 'outputFilename':
                    options.outputFilename = v;
                    break;
                case 'firstHeadingLevel':
                    options.firstHeadingLevel = Number(v);
                    break;
                case 'noTitle':
                    options.noTitle = (v === 'true');
                    break;
                case 'readmeMerge':
                    options.readmeMerge = (v === 'true');
                    break;
                case 'nothingPrivate':
                    options.nothingPrivate = (v === 'true');
                    break;
                case 'filenameSubString':
                    options.filenameSubString = v;
                    break;
                case 'noDetailsSummary':
                    options.noDetailsSummary = (v === 'true');
                    break;
                default: break;
            }
        }
        console.log('ts2md(', options, ')');
    }
    else {
        console.log('ts2md command line ignored.\nts2md(', options, ')');
    }
    if (options.options) {
        const mdLinksEx = {};
        for (const o of options.options) {
            const t = new TypescriptToMarkdown_1.TypescriptToMarkdown(o);
            const r = t.run();
            const base = path.parse(r.outputPath).base;
            for (const [key, mdLink] of Object.entries(r.mdLinks)) {
                if (!mdLinksEx[key]) {
                    mdLinksEx[key] = mdLink.replace('(#', `(./${base}#`);
                }
            }
        }
        for (const o of options.options) {
            const t = new TypescriptToMarkdown_1.TypescriptToMarkdown(o, mdLinksEx);
            t.run();
        }
    }
    else {
        new TypescriptToMarkdown_1.TypescriptToMarkdown(options).run();
    }
}
exports.ts2md = ts2md;
ts2md();
//# sourceMappingURL=ts2md.js.map