"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocBase = exports.DocItem = exports.getJsDocInfo = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const typescript_1 = __importDefault(require("typescript"));
const os_1 = require("os");
/** Regex to parse TypeScript tokens */
const tsTokenRegex = new RegExp([
    '(?:\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\/)',
    '("(?:[^"\\\\]|\\\\.)*"|\'(?:[^\'\\\\]|\\\\.)*\')',
    '(\\b\\d+(\\.\\d+)?\\b)',
    '(\\b(?:if|else|for|while|do|switch|case|break|continue|return|function|class|interface|enum|extends|implements|new|try|catch|finally|throw|void|public|protected|private|readonly|static|async|await|import|export|from|const|let|var|type|as|declare|default)\\b)',
    '(\\b[A-Za-z_$][A-Za-z0-9_$]*\\b)',
    '([{}()\\[\\];,.:])',
    '([+\\-*/%&|^!?<>]=?|={1,3}|~|=>)' // Operators
].join('|'), 'g');
/**
 * Parse available JSDoc information on this node.
 *
 * @private
 */
function getJsDocInfo(node, name, parent) {
    const r = {
        isPrivate: false,
        comments: [],
        params: [],
        returns: [],
        throws: [],
        examples: [],
        tags: [],
        other: [],
        publicBody: false,
        privateInitializer: false,
        properties: {}
    };
    if (name !== 'constructor' && parent && parent.jsDoc.properties[name])
        // Forward @property tags on the parent to this node by name
        r.comments.push(parent.jsDoc.properties[name]);
    const jsDoc = (node['jsDoc']) ? node['jsDoc'] : [];
    for (const doc of jsDoc) {
        const comment = doc['comment'];
        if (comment && typeof comment === 'string')
            r.comments.push(comment);
        for (const t of (doc['tags'] ? doc['tags'] : [])) {
            const comment = typeof t['comment'] === 'string' ? t['comment'] : undefined;
            if (t.kind === typescript_1.default.SyntaxKind.JSDocParameterTag) {
                if (comment)
                    r.params.push(t);
            }
            else if (t.kind === typescript_1.default.SyntaxKind.JSDocReturnTag) {
                if (comment)
                    r.returns.push(t);
            }
            else if (t.kind === typescript_1.default.SyntaxKind.JSDocThrowsTag) {
                if (comment)
                    r.throws.push(t);
            }
            else {
                const tag = t.kind === typescript_1.default.SyntaxKind.JSDocTag ? t.tagName.escapedText : '';
                if (tag === 'publicbody') {
                    r.publicBody = true;
                }
                else if (tag === 'privateinitializer') {
                    r.privateInitializer = true;
                }
                else if (tag === 'property') {
                    if (comment) {
                        const re = /(?<identifier>[^ \t\-:]+)[ \t\-:]+(?<comment>.*)/;
                        const m = comment.match(re);
                        if (m && m.index === 0 && m.groups) {
                            r.properties[m.groups.identifier] = m.groups.comment;
                        }
                    }
                }
                else if (tag === 'example') {
                    if (comment) {
                        let example = comment;
                        if (example.indexOf('```') === -1)
                            example = '```ts' + os_1.EOL + example + os_1.EOL + '```' + os_1.EOL;
                        r.examples.push(example);
                    }
                }
                else
                    r.tags.push(t);
            }
        }
    }
    return r;
}
exports.getJsDocInfo = getJsDocInfo;
/**
 * Wrapper for a Typescript `Node` of a specific derived type,
 * which is of interest for documentation generation.
 *
 * @private
 */
class DocItem {
    /**
     * This is really here just for demonstration / testing purposes...
     * @param item The typescript Node for this doc item.
     * @param name The name for this doc item.
     * @param sf The source file which defined this item.
     */
    constructor(item, name, sf, parent) {
        this.item = item;
        this.name = name;
        this.sf = sf;
        this.parent = parent;
        /**
         * Subsidiary documentation nodes when the node has members which
         * are themselves represented as documentation nodes.
         */
        this.memberDocs = [];
        this.jsDoc = getJsDocInfo(item, name, parent);
    }
}
exports.DocItem = DocItem;
/**
 * @private
 */
class DocBase {
    constructor(sup, label, labelPlural, detailsLabel = 'Details') {
        this.sup = sup;
        this.label = label;
        this.labelPlural = labelPlural;
        this.detailsLabel = detailsLabel;
        this.docItems = [];
    }
    tryAddItem(s, sf, parent) {
        const items = this.filterItem(s);
        for (const item of items) {
            const docItem = new DocItem(item, this.getName(item, sf), sf, parent);
            if (!docItem.jsDoc.isPrivate || this.sup.nothingPrivate) {
                docItem.memberDocs = this.extractMemberDocs(docItem);
                for (const md of docItem.memberDocs) {
                    md.docItems.sort((a, b) => a.name < b.name ? -1 : a.name === b.name ? 0 : 1);
                }
                this.docItems.push(docItem);
            }
        }
    }
    extractMemberDocs(docItem) { return []; }
    isNotPrivate(item) {
        var _a, _b;
        // not private if either we don't care if its private
        const notPrivate = (this.sup.nothingPrivate ||
            // Or it isn't private, which is either by having the private keyword
            !((item['modifiers'] && item['modifiers'].some(m => m.kind === typescript_1.default.SyntaxKind.PrivateKeyword)) ||
                (
                // or by having private jsdoc tag
                (_a = item['jsDoc']) === null || _a === void 0 ? void 0 : _a.some(t => typescript_1.default.isJSDocPrivateTag(t))) ||
                ((_b = item['jsDoc']) === null || _b === void 0 ? void 0 : _b.some(t => { var _a; return (_a = t['tags']) === null || _a === void 0 ? void 0 : _a.some(r => typescript_1.default.isJSDocPrivateTag(r)); }))));
        return notPrivate;
    }
    findTs(findInTs, targetTs) {
        let pos = findInTs.indexOf(targetTs);
        if (pos === -1) {
            // Try outdenting once
            const regex1 = os_1.EOL === '\n' ? /\n/g : /\r\n/g;
            targetTs = targetTs.replace(regex1, os_1.EOL + '    ');
            pos = findInTs.indexOf(targetTs);
            if (pos === -1) {
                // set and get accessor bodies sometimes are inlined in full generated class typescript
                // remove all indenting
                const regex2 = os_1.EOL === '\n' ? /\n */g : /\r\n */g;
                targetTs = targetTs.replace(regex2, ' ');
                pos = findInTs.indexOf(targetTs);
            }
        }
        return { pos, len: targetTs.length };
    }
    removeTs(fromTs, removeTs, withSemi) {
        const r = this.findTs(fromTs, removeTs);
        // See if we would leave a dangling semicolon behind
        if (r.pos > -1 && withSemi && r.pos + r.len + os_1.EOL.length < fromTs.length && fromTs[r.pos + r.len] === ';' && fromTs.slice(r.pos + r.len + 1, r.pos + r.len + 1 + os_1.EOL.length) === os_1.EOL) {
            r.len += 1 + os_1.EOL.length;
            // and remove leading spaces
            while (r.pos > 0 && fromTs[r.pos - 1] === ' ') {
                r.pos--;
                r.len++;
            }
        }
        if (r.pos > -1) {
            fromTs = fromTs.slice(0, r.pos) + fromTs.slice(r.pos + r.len);
            // If EOL follows what we removed...
            if (fromTs.slice(r.pos, r.pos + os_1.EOL.length) === os_1.EOL) {
                let pos2 = r.pos - 1;
                while (pos2 > 0 && fromTs[pos2] === ' ')
                    pos2--;
                if (fromTs.slice(pos2 + 1 - os_1.EOL.length, pos2 + 1) === os_1.EOL) {
                    // and remove blank line left after original removal
                    fromTs = fromTs.slice(0, pos2 + 1 - os_1.EOL.length) + fromTs.slice(r.pos);
                }
            }
        }
        return fromTs;
    }
    toSeeAlso(docItem, mdts, mdLinks, tight) {
        const mdtsLinks = [];
        const tokens = Array.from(mdts.matchAll(tsTokenRegex)).map(t => t[0]);
        const linkTokens = Object.keys(mdLinks).sort((a, b) => a < b ? -1 : a === b ? 0 : 1);
        for (const token of linkTokens) {
            if (token !== docItem.name && tokens.indexOf(token) > -1) {
                mdtsLinks.push(mdLinks[token]);
            }
        }
        let md = tight ? '' : os_1.EOL;
        if (mdtsLinks.length === 0)
            return md;
        md += 'See also: ' + mdtsLinks.join(', ') + os_1.EOL;
        if (!tight)
            md += os_1.EOL;
        return md;
    }
    toTsMarkDown(docItem, mdLinks, tight) {
        const mdts = this.toMarkDownTs(docItem);
        if (!mdts)
            return '';
        return '```ts' + os_1.EOL + mdts + os_1.EOL + '```' + os_1.EOL + this.toSeeAlso(docItem, mdts, mdLinks, tight);
    }
    /**
     * Base class implementation of markdown generation for a top level typescript AST node (`DocItem`).
     *
     * Adds relative level 3 heading with `label` and `docItem.name`
     *
     * Adds the nodes simple (no `@` tag) JSDoc nodes under relative level 4 'Description` heading
     *
     * Calls the `toMarkDownTs` override to add the typescript syntax code block for this node.
     *
     * Calls the `toMarkDownDtails` override to add any details markdown for this node.
     *
     * @returns the generated markdown for this `DocItem`
     */
    toMarkDown(docItem, mdLinks) {
        let md = `${this.sup.headingLevelMd(3)} ${this.label}: ${docItem.name}` + os_1.EOL + os_1.EOL;
        md += this.commentsDetails(docItem);
        md += this.examplesDetails(docItem);
        md += this.toTsMarkDown(docItem, mdLinks);
        const details = this.toMarkDownDetails(docItem, mdLinks);
        if (details) {
            if (this.sup.noDetailsSummary) {
                md += details;
            }
            else {
                md += `<details>${os_1.EOL}${os_1.EOL}<summary>${this.label} ${docItem.name} ${this.detailsLabel}</summary>` + os_1.EOL + os_1.EOL;
                md += details;
                md += `</details>` + os_1.EOL + os_1.EOL;
            }
        }
        return md;
    }
    /**
     * Generate the typescript syntax for this node to be inserted in a typescript syntax code block
     * in generated markdown.
     *
     * Base class implementation uses the typescript compiler printer on `DocItem` AST node `item`.
     *
     * CAUTION: This adds ALL the source code for this item to the generated markdown. Override SHOULD
     * implement appropriate ommission control policies.
     *
     * @returns typescript syntax to be added within a typescript syntax code block for this `DocItem`
     */
    toMarkDownTs(docItem) {
        let item = docItem.item;
        if (item['initializer'] && docItem.jsDoc.privateInitializer) {
            item = { ...item };
            item['initializer'] = undefined;
        }
        const mdts = this.sup.printer.printNode(typescript_1.default.EmitHint.Unspecified, item, docItem.sf);
        return mdts;
    }
    /**
     * Generate the 'Details' markdown (including ) for this node.
     *
     * Base class implementation returns an empty string.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toMarkDownDetails(docItem, mdLinks) {
        return '';
    }
    toMarkDownRefLink(docItem) {
        return `[${docItem.name}](#${this.label.toLowerCase()}-${docItem.name.toLowerCase()})`;
    }
    isExportedDeclaration(item) {
        const modFlags = typescript_1.default.getCombinedModifierFlags(item);
        const hasExportFlag = !!(modFlags & typescript_1.default.ModifierFlags.Export);
        return hasExportFlag;
    }
    argumentsDetails(docItem) {
        let md = '';
        if (docItem.jsDoc.params.length > 0) {
            md += `Argument Details` + os_1.EOL + os_1.EOL;
            for (const tag of docItem.jsDoc.params) {
                const name = tag.name.getText(docItem.sf);
                let comment = tag.comment;
                if (typeof comment === 'string') {
                    if ((comment === null || comment === void 0 ? void 0 : comment.indexOf('- ')) === 0)
                        // remove leading '- ' if present
                        comment = comment.slice(2);
                    md += `+ **${name}**${os_1.EOL}  + ${comment}${os_1.EOL}`;
                }
            }
            md += os_1.EOL + '';
        }
        return md;
    }
    returnsDetails(docItem) {
        let md = '';
        if (docItem.jsDoc.returns.length > 0) {
            md += `Returns` + os_1.EOL + os_1.EOL;
            for (const t of docItem.jsDoc.returns) {
                md += `${t.comment}` + os_1.EOL + os_1.EOL;
            }
        }
        return md;
    }
    throwsDetails(docItem) {
        let md = '';
        if (docItem.jsDoc.throws.length > 0) {
            md += `Throws` + os_1.EOL + os_1.EOL;
            for (const tag of docItem.jsDoc.throws) {
                md += `${tag.comment}` + os_1.EOL + os_1.EOL;
            }
        }
        return md;
    }
    examplesDetails(docItem) {
        let md = '';
        if (docItem.jsDoc.examples.length > 0) {
            md += `Example${docItem.jsDoc.examples.length > 1 ? 's' : ''}` + os_1.EOL + os_1.EOL;
            for (const e of docItem.jsDoc.examples) {
                md += `${e}${os_1.EOL}`;
            }
        }
        return md;
    }
    commentsDetails(docItem) {
        let md = '';
        for (const comment of docItem.jsDoc.comments) {
            md += `${comment}` + os_1.EOL + os_1.EOL;
        }
        return md;
    }
}
exports.DocBase = DocBase;
//# sourceMappingURL=JSDocs.js.map