"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transpiler = void 0;
const typescript_1 = __importStar(require("typescript"));
const tsquery_1 = require("@phenomnomnominal/tsquery");
const console_1 = require("console");
const indexerReader_1 = require("./indexerReader");
const path = __importStar(require("path"));
const utils_1 = require("./utils");
const scryptlib_1 = require("scryptlib");
const os_1 = require("os");
const fs_1 = require("fs");
const types_1 = require("./types");
const typescript_2 = require("typescript");
const snippets_1 = require("./snippets");
/**
 * @ignore
 */
const DEFAULT_AST_COMPILE_OPTS = Object.freeze({
    ast: true,
    asm: false,
    hex: false,
    debug: false,
    artifact: false,
    sourceMap: false,
    outputToFiles: true,
    cmdArgs: '--std'
});
/**
 * @ignore
 */
var DecoratorName;
(function (DecoratorName) {
    DecoratorName["Prop"] = "prop";
    DecoratorName["Method"] = "method";
})(DecoratorName || (DecoratorName = {}));
/**
 * @ignore
 */
class EmittedLine {
    constructor(prefixTabs = 0, currentCol = 0, codeLines = "", sourceMap = []) {
        this.prefixTabs = prefixTabs;
        this.currentCol = currentCol;
        this.code = codeLines;
        this.sourceMap = sourceMap;
    }
    copy() {
        return new EmittedLine(this.prefixTabs, this.currentCol, this.code, JSON.parse(JSON.stringify(this.sourceMap)));
    }
    findByCol(col) {
        for (let i = 0; i < this.sourceMap.length; i++) {
            const sourceMap = this.sourceMap[i];
            if (col >= sourceMap[0]) {
                const nextSourceMap = this.sourceMap[i + 1];
                if (nextSourceMap && col <= nextSourceMap[0]) {
                    return sourceMap;
                }
                else if (!nextSourceMap) {
                    return sourceMap;
                }
            }
        }
        return this.sourceMap[0];
    }
}
/**
 * @ignore
 */
class EmittedSection {
    constructor(initialLine) {
        this.lines = [];
        this.errors = [];
        if (initialLine)
            this.lines.push(initialLine);
        this.skipNextAppend = false;
    }
    static join(...sections) {
        let completed = new EmittedSection();
        sections.forEach(sec => completed.concat(sec));
        return completed;
    }
    getLastLine() {
        return this.lines[this.lines.length - 1];
    }
    getCode() {
        return this.lines.map(l => l.code).join('\n');
    }
    getSourceMap() {
        return this.lines.map(l => l.sourceMap);
    }
    append(code, srcLocation) {
        var _a;
        if (this.skipNextAppend) {
            this.skipNextAppend = false;
            return this;
        }
        let lastLine = this.getLastLine();
        let inlineCode = code.replaceAll(/\n/g, '');
        let startNewLine = code.startsWith("\n");
        if (startNewLine || !lastLine) {
            let prefixTab = (_a = lastLine === null || lastLine === void 0 ? void 0 : lastLine.prefixTabs) !== null && _a !== void 0 ? _a : 0;
            lastLine = new EmittedLine(prefixTab, prefixTab * 2, Array(prefixTab * 2).fill(' ').join('') + inlineCode);
            this.lines.push(lastLine);
        }
        else {
            lastLine.code += inlineCode;
        }
        if (srcLocation) {
            // adjust col to skip prefix spaces
            let skipSpaceCol = inlineCode.search(/[^ ]/);
            let adjustCol = lastLine.currentCol + (skipSpaceCol > 0 ? skipSpaceCol : 0);
            // sourcemap format: [ generatedCodeColumn, sourceIndex, sourceCodeLine, sourceCodeColumn, nameIndex? ]
            lastLine.sourceMap.push([adjustCol, 0, srcLocation.line, srcLocation.character]);
        }
        lastLine.currentCol += inlineCode.length;
        return this;
    }
    appendWith(ctx, updater, increaseTab = false) {
        if (this.skipNextAppend) {
            this.skipNextAppend = false;
            return this;
        }
        try {
            // use the last line of current section as the start line of upcoming section
            let initialLine = (this.getLastLine() || new EmittedLine()).copy();
            if (increaseTab) {
                initialLine.prefixTabs += 1;
            }
            this.concat(updater.call(ctx, new EmittedSection(initialLine)), true);
            if (increaseTab) {
                this.getLastLine().prefixTabs -= 1;
            }
        }
        catch (err) {
            if (err instanceof types_1.TranspileError) {
                this.errors.push(err);
            }
            else {
                throw err;
            }
        }
        return this;
    }
    concat(postSection, lastLineOverlays = false) {
        if (lastLineOverlays)
            this.lines.pop();
        this.lines = this.lines.concat(postSection.lines);
        this.errors = this.errors.concat(postSection.errors);
        return this;
    }
}
const InjectedParamTxPreimage = "__scrypt_ts_txPreimage";
const InjectedParamChangeAmountVar = "__scrypt_ts_changeAmount";
const InjectedParamChangeAddressVar = "__scrypt_ts_changeAddress";
const InjectedParamAccessPathPrefix = "__scrypt_ts_accessPathForProp__";
const InjectedPropAccessPathReaderPrefix = "__scrypt_ts_accessPathReaderForProp__";
const InjectedParamPrevoutsVar = "__scrypt_ts_prevouts";
const InjectedCtxVerionProp = "__scrypt_ts_ctx_version";
const InjectedCtxHashPrevoutsProp = "__scrypt_ts_ctx_hashprevouts";
const InjectedCtxHashSequenceProp = "__scrypt_ts_ctx_hashsequence";
const InjectedCtxHashOutputsProp = "__scrypt_ts_ctx_hashoutputs";
const InjectedCtxLocktimeProp = "__scrypt_ts_ctx_locktime";
const InjectedCtxSequenceProp = "__scrypt_ts_ctx_sequence";
const InjectedCtxSigHashTypeProp = "__scrypt_ts_ctx_sighashtype";
const InjectedCtxOutpointTxidProp = "__scrypt_ts_ctx_outpoint_txid";
const InjectedCtxOutpointOutputIndexProp = "__scrypt_ts_ctx_outpoint_outputindex";
const InjectedCtxScriptCodeProp = "__scrypt_ts_ctx_scriptcode";
const InjectedCtxValueProp = "__scrypt_ts_ctx_value";
const InjectedCtxPreimageProp = "__scrypt_ts_ctx_preimage";
const InjectedChangeProp = "__scrypt_ts_change";
const InjectedPrevoutsProp = "__scrypt_ts_prevouts";
const SmartContractBuildinsFuncs = ["buildChangeOutput",
    "getStateScript", "timeLock", 'buildStateOutput', 'checkSig', 'checkMultiSig',
    "checkPreimageAdvanced", "checkPreimageSigHashType", 'checkPreimage', 'insertCodeSeparator',
];
/**
 * @ignore
 */
class Transpiler {
    constructor(sourceFile, host, checker, tsRootDir, scryptOutDir, indexer, compilerOptions) {
        this.scComponents = [];
        // public publicMethods: ts.MethodDeclaration[] = [];
        this.methodInfos = new Map();
        this.propInfos = new Map();
        this._localTypeSymbols = new Map();
        this._importedTypeSymbols = new Map();
        this._watch = false;
        this._constructorParametersMap = new Map();
        this._srcFile = sourceFile;
        this._host = host;
        this._checker = checker;
        this._tsRootDir = tsRootDir;
        this._scryptOutDir = scryptOutDir;
        this._indexer = indexer;
        this._compilerOptions = compilerOptions;
        this._watch = compilerOptions.watch || false;
        this.searchSmartContractComponents();
        this.searchTopCtcs();
    }
    get ctxMethods() {
        return this.getCtxMethodInfos().map(info => info.name);
    }
    get _scryptRelativePath() {
        return this.getRelativePathFromTsRoot(this._srcFile.fileName);
    }
    get _scryptFullPath() {
        return path.join(this._scryptOutDir, this._scryptRelativePath);
    }
    get currentContractName() {
        return this._currentContract.name.getText();
    }
    get currentbaseContractName() {
        return Transpiler.getBaseContractName(this._currentContract);
    }
    get currentbaseContract() {
        return Transpiler.abstractContractAst.get(this.currentbaseContractName);
    }
    get _transformationResultRelativePath() {
        return (0, utils_1.alterFileExt)(this._scryptRelativePath, "transformer.json");
    }
    get _transformationResultFullPath() {
        return (0, utils_1.alterFileExt)(this._scryptFullPath, "transformer.json");
    }
    get _sourceMapRelativePath() {
        return (0, utils_1.alterFileExt)(this._scryptRelativePath, "scrypt.map");
    }
    get _sourceMapFullPath() {
        return (0, utils_1.alterFileExt)(this._scryptFullPath, "scrypt.map");
    }
    setLocalSymbols(localTypeSymbols) {
        this._localTypeSymbols = localTypeSymbols;
    }
    transform(allmissSym) {
        // console.log(`transform ${this._srcFile.fileName} to ${this._outFilePath}`)
        let contractAndLibs = this.scComponents.map(cDef => this.transformClassDeclaration(cDef));
        let structs = this.transformTypeLiteralAndInterfaces();
        let imports = this.transformImports(allmissSym);
        let result = EmittedSection.join(imports, structs, ...contractAndLibs);
        if (this._watch) {
            setTimeout(() => {
                this.diagnose(result.errors);
            }, 500);
        }
        else {
            this.outputScrypt(result);
            const errors = this.checkTransformedScrypt(result);
            result.errors.push(...errors);
            this.diagnose(result.errors);
            this.outputSourceMapFile(result);
            this.updateIndex();
            this.outputTransformationResult(result);
        }
        return result;
    }
    isTransformable() {
        return this.scComponents.length > 0;
    }
    getSCComponents() {
        return this.scComponents;
    }
    isFromThirdParty(filepath) {
        return filepath.endsWith(".d.ts");
    }
    outputScrypt(result) {
        typescript_1.default.sys.writeFile(this._scryptFullPath, result.getCode());
    }
    outputTransformationResult(result) {
        let transResult = {
            success: result.errors.length === 0,
            errors: result.errors,
            scryptfile: this._scryptRelativePath,
            sourceMapFile: this._sourceMapRelativePath,
            ctxMethods: this.ctxMethods
        };
        typescript_1.default.sys.writeFile(this._transformationResultFullPath, JSON.stringify(transResult, null, 2));
    }
    diagnose(errors) {
        errors.forEach(error => this.outputDiagnostic(error));
    }
    outputDiagnostic(diag) {
        console.log(`scrypt-ts ERROR - ${diag.srcRange.fileName}:${diag.srcRange.start.line}:${diag.srcRange.start.character}:${diag.srcRange.end.line}:${diag.srcRange.end.character} - ${diag.message}\n`);
    }
    // check transformed scrypt code to collect compile time errors
    checkTransformedScrypt(result) {
        if (result.errors.length === 0 && (0, fs_1.existsSync)(this._scryptFullPath)) {
            try {
                const tmpDir = (0, fs_1.mkdtempSync)(path.join((0, os_1.tmpdir)(), "scrypt-ts-"));
                const input = {
                    path: this._scryptFullPath,
                    content: result.getCode()
                };
                const settings = Object.assign({}, DEFAULT_AST_COMPILE_OPTS, {
                    cmdPrefix: (0, scryptlib_1.findCompiler)(),
                    outputDir: tmpDir
                });
                const astResult = (0, scryptlib_1.compile)(input, settings);
                const errors = this.compileError2transpileError(astResult.errors, result.lines);
                return errors;
            }
            catch (err) {
                // for the case when scrypt compiler crushed.
                return [new types_1.TranspileError(`Internal compilation FATAL error raised for auto-generated file: ${this._scryptFullPath} , please report it as a bug to scrypt-ts\n${err}`, {
                        fileName: this._scryptFullPath,
                        start: { line: -1, character: -1 },
                        end: { line: -1, character: -1 }
                    })];
            }
        }
        return [];
    }
    compileError2transpileError(errors, scryptLines) {
        const tsSrcLines = this._srcFile.getFullText().split('\n');
        return errors.map(error => {
            var _a, _b, _c, _d, _f;
            const scryptLine = scryptLines[(((_a = error.position[0]) === null || _a === void 0 ? void 0 : _a.line) || 0) - 1];
            const sourcemap = scryptLine ? scryptLine.findByCol(((_b = error.position[0]) === null || _b === void 0 ? void 0 : _b.column) || -1) : undefined;
            if (sourcemap) {
                const tsLine = sourcemap[2];
                const tsColumn = sourcemap[3];
                // code from current column to end of line
                const tsCode = tsSrcLines[tsLine].slice(tsColumn).replace(/\/\/.*/, "").trim();
                return new types_1.TranspileError(`The code '${tsCode}' was successfully transformed but compiled with error: ${error.message}`, {
                    fileName: this._srcFile.fileName,
                    start: { line: tsLine, character: tsColumn },
                    end: { line: tsLine, character: tsColumn + tsCode.length }
                });
            }
            else {
                // when can not find sourcemap for the certain `scryptLine`, use the first sourcemap
                const sourcemap = (_c = scryptLines[1]) === null || _c === void 0 ? void 0 : _c.sourceMap[0];
                return new types_1.TranspileError(`Internal compilation error raised for auto-generated file: ${this._scryptFullPath}:${((_d = error.position[0]) === null || _d === void 0 ? void 0 : _d.line) || -1}:${((_f = error.position[0]) === null || _f === void 0 ? void 0 : _f.column) || -1} , please report it as a bug to scrypt-ts`, {
                    fileName: this._srcFile.fileName,
                    start: { line: sourcemap ? sourcemap[2] : -1, character: sourcemap ? sourcemap[3] : -1 },
                    end: { line: -1, character: -1 }
                });
            }
        });
    }
    outputSourceMapFile(result) {
        typescript_1.default.sys.writeFile(this._sourceMapFullPath, JSON.stringify(result.getSourceMap()));
    }
    updateIndex() {
        const globalSymbols = Array.from(this._localTypeSymbols.entries())
            .map(([symbolName, symbol]) => {
            const symbolFile = this.findDeclarationFile(symbol);
            let symbolDec = symbol.declarations[0];
            symbolDec = symbolDec.name || symbolDec;
            return {
                name: symbolName,
                srcRange: {
                    fileName: symbolFile.fileName,
                    start: symbolFile.getLineAndCharacterOfPosition(symbolDec.getStart()),
                    end: symbolFile.getLineAndCharacterOfPosition(symbolDec.getEnd())
                }
            };
        });
        this._indexer.addSymbols(globalSymbols, this._scryptRelativePath);
    }
    isExtendsSCComponent(node) {
        if (this.isContract(node)) {
            if ((0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.AbstractKeyword)) {
                Transpiler.abstractContractAst.set(node.name.getText(), node);
                // ignore abstract class, then are base contract class
                return false;
            }
            return true;
        }
        return this.isLibrary(node);
    }
    isContract(node) {
        if (Array.isArray(node.heritageClauses) && node.heritageClauses.length === 1) {
            let clause = node.heritageClauses[0];
            if (clause.token == typescript_1.default.SyntaxKind.ExtendsKeyword && clause.types.length === 1) {
                let baseContractName = Transpiler.getBaseContractName(node);
                return baseContractName === "SmartContract" || Transpiler.abstractContractAst.has(baseContractName);
            }
        }
        return false;
    }
    static getBaseContractName(node) {
        if (Array.isArray(node.heritageClauses) && node.heritageClauses.length === 1) {
            let clause = node.heritageClauses[0];
            if (clause.token == typescript_1.default.SyntaxKind.ExtendsKeyword && clause.types.length === 1) {
                return clause.types[0].getText();
            }
        }
        throw new Error(`Can't get base contract for class ${node.name.getText()}`);
    }
    isInherited(node) {
        if (node.heritageClauses.length === 1 &&
            node.heritageClauses[0].token === typescript_1.default.SyntaxKind.ExtendsKeyword) {
            const baseContractName = Transpiler.getBaseContractName(node);
            return Transpiler.abstractContractAst.has(baseContractName);
        }
        return false;
    }
    isTranspilingConstructor(node) {
        if (!node.parent) {
            return false;
        }
        if (typescript_1.default.isConstructorDeclaration(node.parent)) {
            return true;
        }
        return this.isTranspilingConstructor(node.parent);
    }
    isTranspilingBaseContract(node) {
        const cls = Transpiler.getClassDeclaration(node);
        if (cls.name.getText() !== this.currentContractName) {
            return true;
        }
    }
    isLibrary(node) {
        var _a;
        if ((node === null || node === void 0 ? void 0 : node.heritageClauses.length) === 1 &&
            (node === null || node === void 0 ? void 0 : node.heritageClauses[0].token) === typescript_1.default.SyntaxKind.ExtendsKeyword) {
            const parentClassName = (_a = node === null || node === void 0 ? void 0 : node.heritageClauses[0].types[0]) === null || _a === void 0 ? void 0 : _a.getText();
            return parentClassName === "SmartContractLib";
        }
        return false;
    }
    /**
     * get relative path starting from `tsRootDir`
     * @param fullFilePath
     * @param ext extension of the path
     * @returns
     */
    getRelativePathFromTsRoot(fullFilePath, ext = 'scrypt') {
        // ts source file to root dir relative path which will be kept in scrypt output structure.
        let root2srcRelativePath = path.relative(this._tsRootDir, fullFilePath).replaceAll('\\', '/');
        if (root2srcRelativePath.startsWith("src/contracts/")) {
            root2srcRelativePath = root2srcRelativePath.replace("src/contracts/", "");
        }
        if (root2srcRelativePath.startsWith("../")) {
            root2srcRelativePath = root2srcRelativePath.replace("../", "");
        }
        const basename = path.basename(root2srcRelativePath, path.extname(root2srcRelativePath));
        return path.join(path.dirname(root2srcRelativePath), `${basename}.${ext}`).replaceAll('\\', '/');
    }
    getRelativePathFromArtifacts(fullFilePath, ext = 'scrypt') {
        // ts source file to root dir relative path which will be kept in scrypt output structure.
        let relativePath = path.relative(this._scryptOutDir, fullFilePath).replaceAll('\\', '/');
        const basename = path.basename(relativePath, path.extname(relativePath));
        return path.join(path.dirname(relativePath), `${basename}.${ext}`).replaceAll('\\', '/');
    }
    searchSmartContractComponents() {
        const scComponentDefs = (0, tsquery_1.tsquery)(this._srcFile, "ClassDeclaration:has(HeritageClause)");
        let scComponents = scComponentDefs.filter((cDef) => this.isExtendsSCComponent(cDef));
        scComponents.forEach(cDef => (0, console_1.assert)(typescript_1.default.isClassDeclaration(cDef)));
        this.scComponents = scComponents;
    }
    searchTopCtcs() {
        const declarations = (0, tsquery_1.tsquery)(this._srcFile, "SourceFile > VariableStatement > VariableDeclarationList");
        const ctcDeclarations = declarations.filter(d => {
            if (typescript_1.default.isVariableDeclarationList(d)) {
                return this.isCtcDeclaration(d.declarations[0]);
            }
        });
        ctcDeclarations.forEach((d) => {
            Transpiler.topCtcs.set(`${(0, utils_1.sha1)(this._srcFile.fileName)}:${d.declarations[0].name.getText()}`, this.evalCtcExpression(d.declarations[0].initializer));
        });
    }
    getCoordinates(pos) {
        return pos ? this._srcFile.getLineAndCharacterOfPosition(pos) : undefined;
    }
    getRange(node) {
        return {
            fileName: this._srcFile.fileName,
            start: this.getCoordinates(node.getStart()),
            end: this.getCoordinates(node.getEnd())
        };
    }
    getResolvedType(node) {
        let symbol = this._checker.getSymbolAtLocation(node);
        return symbol
            ? this._checker.getTypeOfSymbolAtLocation(symbol, symbol.declarations[0])
            : undefined;
    }
    findDeclarationFile(symbol) {
        let node = symbol.declarations[0];
        while (node === null || node === void 0 ? void 0 : node.parent) {
            node = node.parent;
        }
        return typescript_1.default.isSourceFile(node) ? node : undefined;
    }
    transformProps(section, node) {
        const category = this.isContract(node)
            ? 'contract' : 'library';
        node.members.forEach(m => {
            if (m.kind === typescript_1.default.SyntaxKind.PropertyDeclaration) {
                section.appendWith(this, (memSec) => {
                    return this.transformPropertyDeclaration(m, memSec, category);
                });
            }
        });
    }
    checkPropsOverride(node, baseContract) {
        const baseContractProps = baseContract.members.filter(m => Transpiler.isProperty(m))
            .map(m => m.name.getText());
        node.members.forEach(m => {
            if (Transpiler.isProperty(m)) {
                if (baseContractProps.includes(m.name.getText())) {
                    throw new types_1.TranspileError(`Untransformable property: '${m.name.getText()}', already defined in base contract '${baseContract.name.getText()}'`, this.getRange(node));
                }
            }
        });
    }
    checkMethodsOverride(node, baseContract) {
        const baseContractMethods = baseContract.members.filter(m => Transpiler.isMethod(m))
            .map(m => m.name.getText());
        node.members.forEach(m => {
            if (Transpiler.isMethod(m)) {
                if (baseContractMethods.includes(m.name.getText())) {
                    throw new types_1.TranspileError(`Untransformable method: '${m.name.getText()}', already defined in base contract '${baseContract.name.getText()}'`, this.getRange(node));
                }
            }
        });
    }
    transformMethods(section, node) {
        const category = this.isContract(node)
            ? 'contract' : 'library';
        node.members.forEach(m => {
            if (m.kind === typescript_1.default.SyntaxKind.MethodDeclaration) {
                section.appendWith(this, (memSec) => {
                    return this.transformMethodDeclaration(m, memSec, category);
                });
            }
        });
    }
    static create_ctx_function(ctxAccessInfo, section) {
        if (ctxAccessInfo.accessVersion) {
            section.append('\n');
            section.append(`this.${InjectedCtxVerionProp} = SigHash.nVersion(${InjectedParamTxPreimage});`);
        }
        if (ctxAccessInfo.accessHashPrevouts) {
            section.append('\n');
            section.append(`this.${InjectedCtxHashPrevoutsProp} = SigHash.hashPrevouts(${InjectedParamTxPreimage});`);
        }
        if (ctxAccessInfo.accessHashSequence) {
            section.append('\n');
            section.append(`this.${InjectedCtxHashSequenceProp} = SigHash.hashSequence(${InjectedParamTxPreimage});`);
        }
        if (ctxAccessInfo.accessHashOutputs) {
            section.append('\n');
            section.append(`this.${InjectedCtxHashOutputsProp} = SigHash.hashOutputs(${InjectedParamTxPreimage});`);
        }
        if (ctxAccessInfo.accessLocktime) {
            section.append('\n');
            section.append(`this.${InjectedCtxLocktimeProp} = SigHash.nLocktime(${InjectedParamTxPreimage});`);
        }
        if (ctxAccessInfo.accessSequence) {
            section.append('\n');
            section.append(`this.${InjectedCtxSequenceProp} = SigHash.nSequence(${InjectedParamTxPreimage});`);
        }
        if (ctxAccessInfo.accessSigHashType) {
            section.append('\n');
            section.append(`this.${InjectedCtxSigHashTypeProp} = SigHash.sigHashType(${InjectedParamTxPreimage});`);
        }
        if (ctxAccessInfo.accessOutpoint) {
            section.append('\n');
            section.append(`this.${InjectedCtxOutpointOutputIndexProp} = unpack(SigHash.outpoint(${InjectedParamTxPreimage})[32 :]);`);
            section.append('\n');
            section.append(`this.${InjectedCtxOutpointTxidProp} = SigHash.outpoint(${InjectedParamTxPreimage})[0:32];`);
        }
        if (ctxAccessInfo.accessScriptCode) {
            section.append('\n');
            section.append(`this.${InjectedCtxScriptCodeProp} = SigHash.scriptCode(${InjectedParamTxPreimage});`);
        }
        if (ctxAccessInfo.accessValue) {
            section.append('\n');
            section.append(`this.${InjectedCtxValueProp} = SigHash.value(${InjectedParamTxPreimage});`);
        }
        if (ctxAccessInfo.accessSerialize) {
            section.append('\n');
            section.append(`this.${InjectedCtxPreimageProp} = ${InjectedParamTxPreimage};`);
        }
    }
    transformClassDeclaration(node) {
        const className = node.name.getText();
        this._currentContract = node;
        // also add it to local type symbols
        this._localTypeSymbols.set(className, this._checker.getSymbolAtLocation(node.name));
        const category = this.isContract(node)
            ? 'contract' : 'library';
        const baseContract = this.currentbaseContract;
        // Preprocess all methods
        const section = new EmittedSection();
        try {
            this.initAllPropInfos();
            this.initAllMethodInfos();
            this.injectScryptStructs(section);
            section
                .append('\n')
                .append(`\n${category} `)
                .append(`${className} {`, this.getCoordinates(node.name.getStart()))
                .appendWith(this, (membersSection) => {
                if (baseContract) {
                    this.checkPropsOverride(node, baseContract);
                    this.transformProps(membersSection, baseContract);
                }
                this.transformProps(membersSection, node);
                this.injectScryptProps(membersSection);
                this.transformConstructor(membersSection, node, baseContract);
                if (baseContract) {
                    this.checkMethodsOverride(node, baseContract);
                    this.transformMethods(membersSection, baseContract);
                }
                this.transformMethods(membersSection, node);
                if (this.accessTimelock()) {
                    membersSection.append(`\n${snippets_1.TIME_LOCK_FUNCTION}`);
                }
                if (this.accessStateProp()) {
                    membersSection.append(`\n${snippets_1.BUILD_STATE_OUTPUT_FUNCTION}`);
                }
                if (this.accessChange()) {
                    membersSection.append(`\n${snippets_1.BUILD_CHANGE_OUTPUT_FUNCTION}`);
                }
                if (this.getPublicMethodCount() === 0 && category === 'contract') {
                    throw new types_1.TranspileError("A `SmartContract` should have at least one public `@method`", this.getRange(node.name));
                }
                return membersSection;
            }, true)
                .append("\n}");
            let methodInfos = Array.from(this.methodInfos, ([key, methodInfo]) => ({ key, methodInfo }))
                .filter(i => i.key.startsWith(`${className}.`))
                .filter(i => i.methodInfo.codeSeparatorCount > 0);
            if (methodInfos.length > 1) {
                throw new types_1.TranspileError(`insertCodeSeparator() can only be called by one pulic method`, this.getRange(node));
            }
        }
        catch (error) {
            if (error instanceof types_1.TranspileError) {
                section.errors.push(error);
            }
            else {
                throw error;
            }
        }
        return section;
    }
    injectScryptProps(section) {
        if (this.accessCtx()) {
            const accessCtxInfo = this.getCtxAccessInfo();
            if (accessCtxInfo.accessVersion) {
                section.append(`\nbytes ${InjectedCtxVerionProp};`);
            }
            if (accessCtxInfo.accessHashPrevouts) {
                section.append(`\nbytes ${InjectedCtxHashPrevoutsProp};`);
            }
            if (accessCtxInfo.accessHashSequence) {
                section.append(`\nbytes ${InjectedCtxHashSequenceProp};`);
            }
            if (accessCtxInfo.accessHashOutputs) {
                section.append(`\nbytes ${InjectedCtxHashOutputsProp};`);
            }
            if (accessCtxInfo.accessLocktime) {
                section.append(`\nint ${InjectedCtxLocktimeProp};`);
            }
            if (accessCtxInfo.accessSequence) {
                section.append(`\nint ${InjectedCtxSequenceProp};`);
            }
            if (accessCtxInfo.accessSigHashType) {
                section.append(`\nSigHashType ${InjectedCtxSigHashTypeProp};`);
            }
            if (accessCtxInfo.accessOutpoint) {
                section.append(`\nbytes ${InjectedCtxOutpointTxidProp};`);
                section.append(`\nint ${InjectedCtxOutpointOutputIndexProp};`);
            }
            if (accessCtxInfo.accessScriptCode) {
                section.append(`\nbytes ${InjectedCtxScriptCodeProp};`);
            }
            if (accessCtxInfo.accessValue) {
                section.append(`\nint ${InjectedCtxValueProp};`);
            }
            if (accessCtxInfo.accessSerialize) {
                section.append(`\nSigHashPreimage ${InjectedCtxPreimageProp};`);
            }
        }
        if (this.accessChange()) {
            section.append(`\n__scrypt_ts_Change ${InjectedChangeProp};`);
        }
        if (this.accessPrevouts()) {
            section.append(`\nbytes ${InjectedPrevoutsProp};`);
        }
    }
    injectScryptStructs(section) {
        if (this.accessChange()) {
            section.append(snippets_1.CHANGE_STRUCT);
        }
    }
    transformPropertySignature(node, toSection) {
        return this.transformEnclosingTypeNode(node.type || node, toSection)
            .append(` ${node.name.getText()}`, this.getCoordinates(node.name.getStart()))
            .append(';');
    }
    transformPropertyDeclaration(node, toSection, category) {
        if (!Transpiler.isProperty(node))
            return toSection;
        toSection
            .append("\n");
        if (Transpiler.isStateProperty(node)) {
            if (category === "library") {
                const decorator = Transpiler.findDecorator(node, DecoratorName.Prop);
                throw new types_1.TranspileError(`Untransformable property: '${node.name.getText()}', \`@prop(true)\` is only allowed to be used in \`SmartContract\``, this.getRange(decorator.expression));
            }
            if (Transpiler.isStaticProperty(node)) {
                throw new types_1.TranspileError(`Untransformable property: '${node.name.getText()}', \`@prop(true)\` cannot be static`, this.getRange(node));
            }
            if ((0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.ReadonlyKeyword)) {
                throw new types_1.TranspileError(`Untransformable property: '${node.name.getText()}', \`@prop(true)\` cannot be readonly`, this.getRange(node));
            }
            toSection
                .append("@state ");
        }
        else if (Transpiler.isStaticProperty(node)) {
            if (!node.initializer) {
                throw new types_1.TranspileError(`Untransformable property: '${node.name.getText()}', static property shall be initialized when declared`, this.getRange(node));
            }
        }
        toSection
            .appendWith(this, toSec => {
            return this.transformModifiers(node, toSec);
        })
            .appendWith(this, toSec => {
            if (!node.type) {
                throw new types_1.TranspileError(`Untransformable property: '${node.name.getText()}', all \`prop()\` should be typed explicitly`, this.getRange(node));
            }
            return this.transformEnclosingTypeNode(node.type, toSec);
        })
            .append(` ${node.name.getText()}`, this.getCoordinates(node.name.getStart()));
        if (node.initializer) {
            if (Transpiler.isStaticProperty(node)) {
                toSection.append(" = ")
                    .appendWith(this, toSec => {
                    return this.transformExpression(node.initializer, toSec);
                })
                    .append(';');
                return toSection;
            }
            else {
                throw new types_1.TranspileError(`Untransformable property: '${node.name.getText()}', Non-static properties shall only be initialized in the constructor`, this.getRange(node.initializer));
            }
        }
        toSection.append(';');
        // auto append `VarIntReader` for `SortedItemAccessTraceable` property
        const propInfo = this.findPropInfo(node.name.getText());
        if (propInfo && propInfo.isHashed) {
            toSection.append(`\nVarIntReader ${InjectedPropAccessPathReaderPrefix}${node.name.getText()};`);
        }
        return toSection;
    }
    buildConstructorParametersMap(node, baseContract) {
        function getSuperParameters() {
            const superStmt = node.body.statements[0];
            let callexpr = superStmt.expression;
            if (callexpr.arguments[0] && typescript_1.default.isSpreadElement(callexpr.arguments[0]) && callexpr.arguments[0].getText().endsWith("arguments")) {
                return node.parameters;
            }
            else {
                return callexpr.arguments;
            }
        }
        const basector = this.getConstructor(baseContract);
        if (!basector) {
            return;
        }
        const superParameters = getSuperParameters();
        basector.parameters.forEach((parameter, index) => {
            const superParameter = superParameters[index];
            this._constructorParametersMap.set(parameter.name.getText(), superParameter);
        });
    }
    static accessSetConstructor(statements) {
        return statements.findIndex(statement => {
            return (typescript_1.default.isExpressionStatement(statement) && statement.expression.kind === typescript_1.default.SyntaxKind.CallExpression && /^this\.init\(/.test(statement.expression.getText()));
        }) > -1;
    }
    checkSuperStmt(node) {
        const superStmt = node.body.statements[0];
        let callexpr = superStmt.expression;
        if (!typescript_1.default.isCallExpression(callexpr) || callexpr.expression.getText() !== 'super') {
            throw new types_1.TranspileError(`Constructors for derived classes must contain a \`super()\` call`, this.getRange(node));
        }
        if (Transpiler.accessSetConstructor(node.body.statements)) {
            throw new types_1.TranspileError(`Direct subclasses of \`SmartContract\` do not need to call \'this.init()\'.`, this.getRange(node));
        }
        if (callexpr.arguments[0] && typescript_1.default.isSpreadElement(callexpr.arguments[0]) && callexpr.arguments[0].getText().endsWith("arguments")) {
            return;
        }
        if (node.parameters.length !== callexpr.arguments.length) {
            throw new types_1.TranspileError(`All parameters in the constructor must be passed to the \`super()\` call`, this.getRange(node));
        }
        node.parameters.forEach((p, pIdx) => {
            const arg = callexpr.arguments[pIdx];
            if (arg.getText() !== p.name.getText()) {
                throw new types_1.TranspileError(`All parameters in the constructor must be passed to the \`super()\` call following their declaration order`, this.getRange(node));
            }
        });
    }
    checkSetConstructorStmt(node) {
        const superStmt = node.body.statements[0];
        let callexpr = superStmt.expression;
        if (!typescript_1.default.isCallExpression(callexpr) || callexpr.expression.getText() !== 'super') {
            throw new types_1.TranspileError(`Constructors for derived classes must contain a \`super()\` call`, this.getRange(node));
        }
        if (callexpr.arguments[0] && typescript_1.default.isSpreadElement(callexpr.arguments[0]) && callexpr.arguments[0].getText().endsWith("arguments")) {
            return;
        }
        if (node.parameters.length === callexpr.arguments.length) {
            return;
        }
        const setConstructorStmt = node.body.statements[1];
        let setConstructorExpr = setConstructorStmt.expression;
        if (!typescript_1.default.isCallExpression(setConstructorExpr) || setConstructorExpr.expression.getText() !== 'this.init') {
            throw new types_1.TranspileError(`Inherited contract classes must contain a \`this.init(...arguments)\` call`, this.getRange(node));
        }
        if (setConstructorExpr.arguments[0] && typescript_1.default.isSpreadElement(setConstructorExpr.arguments[0]) && setConstructorExpr.arguments[0].getText().endsWith("arguments")) {
            return;
        }
        if (node.parameters.length !== setConstructorExpr.arguments.length) {
            throw new types_1.TranspileError(`All parameters in the constructor must be passed to the \`this.init(...arguments)\` call`, this.getRange(node));
        }
        node.parameters.forEach((p, pIdx) => {
            const arg = setConstructorExpr.arguments[pIdx];
            if (arg.getText() !== p.name.getText()) {
                throw new types_1.TranspileError(`All parameters in the constructor must be passed to the \`this.init(...arguments)\` call following their declaration order`, this.getRange(node));
            }
        });
    }
    canBeImplicitConstructor(node) {
        // Test if it can be an implicit constructor.
        let res = true;
        const ctorParamNames = [];
        node.parameters.forEach((p) => {
            const pText = p.name.getFullText().trim();
            ctorParamNames.push(pText);
        });
        node.body.statements.slice(1).forEach((stmt) => {
            // For each statement in the constr check if its a property init stmt.
            // If not, the constructor cannot be implicit.
            const isPropSet = this.queryPropertyInitializedInStmt(stmt);
            if (!isPropSet) {
                res = false;
                return;
            }
            // If its a prop init stmt, then also check if the value being set is a
            // constructor parameter.
            if (!(0, typescript_1.isExpressionStatement)(stmt) || !(0, typescript_2.isBinaryExpression)(stmt.expression)) {
                res = false;
                return;
            }
            const exprName = stmt.expression.right.getFullText().trim();
            let found = false;
            for (const ctorParamName of ctorParamNames) {
                if (ctorParamName == exprName) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                res = false;
                return;
            }
        });
        // Check the order of the ctor params compared to the order of prop declarations.
        const props = node.parent.members.filter(member => Transpiler.isProperty(member));
        props.forEach((p) => {
            const pName = p.name.getFullText().trim();
            const ctorParamName = ctorParamNames.shift();
            if (pName != ctorParamName) {
                res = false;
                return;
            }
        });
        // Check if the contract contains any non-props. It can still contain static (readonly) non-props.
        const nonProps = node.parent.members.filter(member => this.isNonProp(member) && !this.isStaticReadOnlyNonProp(member));
        if (nonProps.length > 0) {
            res = false;
        }
        // Also check for VarIntReader properties.
        if (this.accessHashededProp() || this.accessCtx() || this.accessChange() || this.accessPrevouts()) {
            res = false;
        }
        return res;
    }
    transformConstructorBody(section, node) {
        const allProps = this.allPropertyDeclaration(node.parent);
        let initializedProps = [];
        node.body.statements.slice(1).forEach((stmt) => {
            section
                .append('\n')
                .appendWith(this, stmtsSec => {
                const prop = this.queryPropertyInitializedInStmt(stmt);
                if (prop) {
                    initializedProps.push(prop);
                    if (!Transpiler.isProperty(prop)) {
                        return stmtsSec; //allow but ignore Non-Prop Property
                    }
                }
                return this.transformStatement(stmt, stmtsSec);
            }, true);
        });
        allProps.forEach(prop => {
            if (!initializedProps.map(p => p.name.getText()).includes(prop.name.getText())) {
                // allowed static const prop initialized
                if (!Transpiler.isStaticProperty(prop)) {
                    throw new types_1.TranspileError(`property \`${prop.name.getText()}\` must be initialized in the constructor`, this.getRange(prop));
                }
            }
        });
        return section;
    }
    transformConstructor(section, cls, baseContract) {
        this.checkConstructor(cls);
        const node = cls.members.find(m => m.kind === typescript_1.default.SyntaxKind.Constructor);
        if (node) {
            if (baseContract) {
                this.buildConstructorParametersMap(node, baseContract);
            }
            section.appendWith(this, (section) => {
                if (!node.body) {
                    throw new types_1.TranspileError(`Missing function body`, this.getRange(node));
                }
                const tmpSection = new EmittedSection();
                tmpSection.lines = section.lines;
                tmpSection.errors = section.errors;
                tmpSection
                    .append('\n')
                    .append('constructor', this.getCoordinates(node.getStart()))
                    .append('(')
                    .appendWith(this, psSec => {
                    node.parameters.forEach((p, pIdx) => {
                        psSec.appendWith(this, pSec => {
                            let sec = this.transformParameter(p, pSec);
                            if (pIdx !== node.parameters.length - 1) {
                                sec.append(', ');
                            }
                            return sec;
                        });
                    });
                    return psSec;
                })
                    .append(') ');
                tmpSection.append('{')
                    .appendWith(this, (sec) => {
                    if (baseContract) {
                        baseContract.members.forEach(member => {
                            if (member.kind === typescript_1.default.SyntaxKind.Constructor) {
                                this.transformConstructorBody(sec, member);
                            }
                        });
                    }
                    return this.transformConstructorBody(sec, node);
                }, true)
                    .append('\n}');
                // If the constructor can be implicit, we don't even have to transform it.
                if (this.canBeImplicitConstructor(node)) {
                    section.errors = tmpSection.errors;
                    return section;
                }
                return tmpSection;
            });
        }
        else {
            if (this.accessHashededProp() || this.accessCtx() || this.accessChange() || this.accessPrevouts()) {
                section.append(`\n${snippets_1.EMPTY_CONSTRUCTOR}`);
                return section;
            }
        }
    }
    transformMethodDeclaration(node, toSection, category) {
        let methodDec = Transpiler.findDecorator(node, DecoratorName.Method);
        if (!methodDec)
            return toSection;
        const match = /^method\((.*)?\)$/.exec(methodDec.expression.getText());
        let sigHashType = '41'; //SigHash.ALL;
        switch (match[1]) {
            case "SigHash.ANYONECANPAY_SINGLE":
                sigHashType = 'c3'; // SigHash.ANYONECANPAY_SINGLE;
                break;
            case "SigHash.ANYONECANPAY_ALL":
                sigHashType = 'c1'; //SigHash.ANYONECANPAY_ALL;
                break;
            case "SigHash.ANYONECANPAY_NONE":
                sigHashType = 'c2'; //SigHash.ANYONECANPAY_NONE;
                break;
            case "SigHash.ALL":
                sigHashType = '41'; //SigHash.ALL;
                break;
            case "SigHash.SINGLE":
                sigHashType = '43'; //SigHash.SINGLE;
                break;
            case "SigHash.NONE":
                sigHashType = '42'; //SigHash.NONE;
                break;
            default:
                break;
        }
        const isPublicMethod = Transpiler.isPublicMethod(node);
        if (isPublicMethod) {
            if (category === 'library') {
                const publicModifier = typescript_1.default.getModifiers(node).find(m => m.kind === typescript_1.default.SyntaxKind.PublicKeyword);
                throw new types_1.TranspileError(`\`@method\` in \`SmartContractLib\` should not be declared as \`public\``, this.getRange(publicModifier));
            }
            const retStmt = (0, utils_1.findReturnStatement)(node);
            if (retStmt) {
                throw new types_1.TranspileError(`public methods cannot contain an explicit return statement`, this.getRange(retStmt));
            }
            if (node.type) {
                // has return type
                throw new types_1.TranspileError(`public methods cannot have a return type`, this.getRange(node.type));
            }
        }
        else {
            if (!node.type) {
                throw new types_1.TranspileError(`non-public methods must declare the return type explicitly`, this.getRange(node));
            }
        }
        if (!node.body) {
            throw new types_1.TranspileError(`Missing function body`, this.getRange(node));
        }
        const shouldAutoAppendSighashPreimage = this.shouldAutoAppendSighashPreimage(node);
        const shouldAutoAppendChangeAmount = this.shouldAutoAppendChangeAmount(node);
        const accessPathProps = this.shouldAutoAppendAccessPaths(node);
        const shouldAutoAppendPrevouts = this.shouldAutoAppendPrevouts(node);
        const buildChangeOutputExpression = (0, utils_1.findBuildChangeOutputExpression)(node);
        if (shouldAutoAppendSighashPreimage && buildChangeOutputExpression !== undefined) {
            const allowedSighashType = ['c1', '41']; // Only sighash ALL allowed.
            if (!allowedSighashType.includes(sigHashType)) {
                throw new types_1.TranspileError(`Can only use sighash ALL or ANYONECANPAY_ALL if using \`this.buildChangeOutput()\``, this.getRange(node));
            }
        }
        toSection
            .append('\n')
            .appendWith(this, toSec => {
            return this.transformModifiers(node, toSec);
        })
            .append('function ')
            .append(node.name.getText(), this.getCoordinates(node.name.getStart()))
            .append('(')
            .appendWith(this, psSec => {
            // not allow SmartContract as parameter
            const inValidParams = node.parameters.find(p => { var _a; return ((_a = p.type) === null || _a === void 0 ? void 0 : _a.getText()) === 'SmartContract'; });
            if (inValidParams) {
                throw new types_1.TranspileError(`Untransformable parameter: '${node.getText()}'`, this.getRange(node));
            }
            node.parameters.forEach((p, pIdx) => {
                psSec.appendWith(this, pSec => {
                    if (this.isHashedMapOrHashedSet(p.name)) {
                        throw new types_1.TranspileError(`\`HashedMap\`/\`HashedSet\`-typed parameter is not allowed`, this.getRange(p.name));
                    }
                    let sec = this.transformParameter(p, pSec);
                    if (pIdx !== node.parameters.length - 1) {
                        sec.append(', ');
                    }
                    return sec;
                });
            });
            let paramLen = node.parameters.length;
            if (shouldAutoAppendSighashPreimage) {
                if (paramLen > 0) {
                    psSec.append(', ');
                }
                psSec.append(`SigHashPreimage ${InjectedParamTxPreimage}`);
                paramLen += 1;
            }
            if (shouldAutoAppendChangeAmount) {
                if (paramLen > 0) {
                    psSec.append(', ');
                }
                psSec.append(`int ${InjectedParamChangeAmountVar}, Ripemd160 ${InjectedParamChangeAddressVar}`);
                paramLen += 2;
            }
            if (shouldAutoAppendPrevouts) {
                if (paramLen > 0) {
                    psSec.append(', ');
                }
                psSec.append(`bytes ${InjectedParamPrevoutsVar}`);
                paramLen += 1;
            }
            // auto append access path parameters for `accessPathProps`
            accessPathProps.forEach(prop => {
                if (paramLen > 0) {
                    psSec.append(', ');
                }
                psSec.append(`bytes ${InjectedParamAccessPathPrefix}${prop}`);
                paramLen += 1;
            });
            return psSec;
        })
            .append(') ');
        // non-public method return type
        let autoReturnStatement = '';
        if (!isPublicMethod) {
            // for non-public method, `node.type` is not `undefined` definitely
            if (node.type.kind !== typescript_1.default.SyntaxKind.VoidKeyword) {
                // return not void
                toSection
                    .append(': ')
                    .appendWith(this, toSec => this.transformEnclosingTypeNode(node.type, toSec))
                    .append(' ');
            }
            else {
                // return void
                toSection.append(': bool ');
                autoReturnStatement = '\n  return true;';
            }
        }
        return toSection.append('{')
            .appendWith(this, (sec) => {
            if (shouldAutoAppendSighashPreimage) {
                sec
                    .append('\n')
                    .append(`require(Tx.checkPreimageSigHashType(${InjectedParamTxPreimage}, SigHashType(b'${sigHashType}')));`);
                Transpiler.create_ctx_function(this.getCtxAccessInfo(), sec);
            }
            if (shouldAutoAppendChangeAmount) {
                sec.append('\n')
                    .append(snippets_1.INIT_CHANGE);
            }
            if (shouldAutoAppendPrevouts) {
                if (sigHashType === "c1" || sigHashType === "c2" || sigHashType === "c3") {
                    sec
                        .append('\n')
                        .append(snippets_1.REQUIRE_PREVOUTS_EMPTY);
                }
                else {
                    sec
                        .append('\n')
                        .append(snippets_1.VERIFY_PREVOUTS);
                }
                sec
                    .append(`\n${snippets_1.INIT_PREVOUTS}`);
            }
            // auto append access path reader init for `accessPathProps`
            accessPathProps.forEach(prop => {
                sec.append(`\nthis.${InjectedPropAccessPathReaderPrefix}${prop} = new VarIntReader(${InjectedParamAccessPathPrefix}${prop});`);
            });
            node.body.statements.forEach((stmt) => {
                sec
                    .append('\n')
                    .appendWith(this, stmtsSec => {
                    return this.transformStatement(stmt, stmtsSec);
                }, true);
            });
            if (isPublicMethod) {
                if (!this.verifyLastAssertStatement(node.body.statements)) {
                    throw new types_1.TranspileError(`Untransformable public method: Public method \`${node.name.getText()}\` not ended with \`assert()\``, this.getRange(node));
                }
                if (this.needAppendLastStatement(node.body.statements)) {
                    sec
                        .append('\n')
                        .append('require(true);\n');
                }
            }
            return sec;
        }, true).append(autoReturnStatement)
            .append('\n}');
    }
    isAssertStatement(node) {
        if (typescript_1.default.isExpressionStatement(node)) {
            const s = node;
            if (typescript_1.default.isCallExpression(s.expression)) {
                const e = s.expression;
                return e.expression.getText() === "assert";
            }
        }
        else if (typescript_1.default.isForStatement(node)) {
            return this.isForStatementAssert(node);
        }
        else if (typescript_1.default.isIfStatement(node)) {
            return this.isIfStatementAssert(node);
        }
        else if (typescript_1.default.isBlock(node)) {
            return this.isBlockStatementAssert(node);
        }
        return false;
    }
    isBlockStatementAssert(node) {
        if (typescript_1.default.isBlock(node)) {
            const block = node;
            if (block.statements.length === 0) {
                return false;
            }
            let i = block.statements.length - 1;
            while (i >= 0 && this.isConsoleLogStatement(block.statements[i])) {
                --i;
            }
            return i >= 0 && this.isAssertStatement(block.statements[i]);
        }
        return false;
    }
    isForStatementAssert(node) {
        if (typescript_1.default.isForStatement(node)) {
            const s = node;
            return this.isAssertStatement(s.statement);
        }
        return false;
    }
    isIfStatementAssert(node) {
        if (typescript_1.default.isIfStatement(node)) {
            const s = node;
            if (s.elseStatement) {
                return this.isAssertStatement(s.thenStatement) && this.isAssertStatement(s.elseStatement);
            }
            return false;
        }
        return false;
    }
    isConsoleLogStatement(node) {
        if (typescript_1.default.isExpressionStatement(node)) {
            const s = node;
            return s.expression.kind === typescript_1.default.SyntaxKind.CallExpression && /^console\.log/.test(s.expression.getText());
        }
        return false;
    }
    verifyLastAssertStatement(statements) {
        if (statements.length === 0) {
            return false;
        }
        let i = statements.length - 1;
        while (i >= 0 && this.isConsoleLogStatement(statements[i])) {
            --i;
        }
        return i >= 0 && this.isAssertStatement(statements[i]);
    }
    needAppendLastStatement(statements) {
        if (statements.length === 0) {
            return false;
        }
        let i = statements.length - 1;
        while (i >= 0 && this.isConsoleLogStatement(statements[i])) {
            --i;
        }
        return i >= 0 && !typescript_1.default.isExpressionStatement(statements[i]);
    }
    hasPropertyAccessExpression(node, propName) {
        if (typescript_1.default.isPropertyAccessExpression(node)) {
            const ae = node;
            if (ae.expression.getText() === 'this' && ae.name.getText() === propName) {
                return true;
            }
        }
        return typescript_1.default.forEachChild(node, node => this.hasPropertyAccessExpression(node, propName));
    }
    hasFunctionCallExpression(node, funcName) {
        if (typescript_1.default.isCallExpression(node)) {
            const callee = node.expression;
            if (typescript_1.default.isPropertyAccessExpression(callee) &&
                callee.expression.getText() === 'this' &&
                callee.name.getText() === funcName) {
                return true;
            }
        }
        return typescript_1.default.forEachChild(node, node => this.hasFunctionCallExpression(node, funcName));
    }
    createMethodAccessInfo(method, currentMethodName, isBase) {
        let accessInfo = {
            accessChange: false,
            accessCtxInfo: {
                accessVersion: false,
                accessHashPrevouts: false,
                accessHashSequence: false,
                accessHashOutputs: false,
                accessLocktime: false,
                accessSequence: false,
                accessSigHashType: false,
                accessOutpoint: false,
                accessScriptCode: false,
                accessValue: false,
                accessSerialize: false
            },
            accessCtx: false,
            accessState: false,
            accessPrevouts: false,
            accessTimelock: false,
            accessHashedProps: []
        };
        const self = this;
        function vistMethodChild(node) {
            if (typescript_1.default.isPropertyAccessExpression(node)) {
                if (node.expression.getText() === 'this') {
                    if (node.name.getText() === "ctx") {
                        Object.assign(accessInfo, {
                            accessCtx: true
                        });
                        if (typescript_1.default.isPropertyAccessExpression(node.parent)) {
                            switch (node.parent.name.getText()) {
                                case "version":
                                    Object.assign(accessInfo.accessCtxInfo, {
                                        accessVersion: true
                                    });
                                    break;
                                case "hashPrevouts":
                                    Object.assign(accessInfo.accessCtxInfo, {
                                        accessHashPrevouts: true
                                    });
                                    break;
                                case "hashSequence":
                                    Object.assign(accessInfo.accessCtxInfo, {
                                        accessHashSequence: true
                                    });
                                    break;
                                case "sequence":
                                    Object.assign(accessInfo.accessCtxInfo, {
                                        accessSequence: true
                                    });
                                    break;
                                case "hashOutputs":
                                    Object.assign(accessInfo.accessCtxInfo, {
                                        accessHashOutputs: true
                                    });
                                    break;
                                case "sigHashType":
                                    Object.assign(accessInfo.accessCtxInfo, {
                                        accessSigHashType: true
                                    });
                                    break;
                                case "locktime":
                                    Object.assign(accessInfo.accessCtxInfo, {
                                        accessLocktime: true
                                    });
                                    break;
                                case "serialize":
                                    {
                                        Object.assign(accessInfo.accessCtxInfo, {
                                            accessSerialize: true
                                        });
                                    }
                                    break;
                                case "utxo":
                                    if (typescript_1.default.isPropertyAccessExpression(node.parent.parent)) {
                                        if (node.parent.parent.name.getText() === 'outpoint') {
                                            Object.assign(accessInfo.accessCtxInfo, {
                                                accessOutpoint: true
                                            });
                                        }
                                        else if (node.parent.parent.name.getText() === 'script') {
                                            Object.assign(accessInfo.accessCtxInfo, {
                                                accessScriptCode: true
                                            });
                                        }
                                        else if (node.parent.parent.name.getText() === 'value') {
                                            Object.assign(accessInfo.accessCtxInfo, {
                                                accessValue: true
                                            });
                                        }
                                    }
                                    break;
                                default:
                            }
                        }
                    }
                    else if (node.name.getText() === 'changeAmount') {
                        Object.assign(accessInfo, {
                            accessChange: true
                        });
                    }
                    else if (node.name.getText() === 'prevouts') {
                        Object.assign(accessInfo, {
                            accessPrevouts: true,
                            accessCtx: true
                        });
                        Object.assign(accessInfo.accessCtxInfo, {
                            accessHashPrevouts: true
                        });
                    }
                    const propName = node.name.getText();
                    const propInfo = self.findPropInfo(propName);
                    if (propInfo) {
                        if (propInfo.isState) {
                            Object.assign(accessInfo, {
                                accessState: true
                            });
                        }
                        if (propInfo.isHashed && !accessInfo.accessHashedProps.includes(propName)) {
                            accessInfo.accessHashedProps.push(propName);
                        }
                    }
                }
            }
            else if (typescript_1.default.isCallExpression(node)) {
                const callee = node.expression;
                if (typescript_1.default.isPropertyAccessExpression(callee) &&
                    callee.expression.getText() === 'this') {
                    const methodName = callee.name.getText();
                    if (methodName === currentMethodName) {
                        throw new types_1.TranspileError(`Cycle detected in function call: this.${methodName}()!`, self.getRange(node));
                    }
                    else if (SmartContractBuildinsFuncs.includes(methodName)) {
                        if (methodName === "buildChangeOutput") {
                            Object.assign(accessInfo, {
                                accessChange: true
                            });
                        }
                        else if (["timeLock"].includes(methodName)) {
                            Object.assign(accessInfo, {
                                accessCtx: true,
                                accessTimelock: true
                            });
                            Object.assign(accessInfo.accessCtxInfo, {
                                accessLocktime: true,
                                accessSequence: true
                            });
                        }
                        else if (["getStateScript", "buildStateOutput"].includes(methodName)) {
                            Object.assign(accessInfo, {
                                accessState: true
                            });
                        }
                    }
                    else {
                        const clsName = Transpiler.getClassDeclaration(node).name.getText();
                        const methodInfo = self.methodInfos.get(`${clsName}.${methodName}`);
                        if (methodInfo) {
                            Transpiler.pickAccessInfo(accessInfo, methodInfo.accessInfo);
                        }
                        else {
                            const m = self.findMethodDeclaration(methodName);
                            if (!m) {
                                const msg = `\`${methodName}\` is not \`@method\` decorated so cannot be called in \`${currentMethodName}\`.`;
                                throw new types_1.TranspileError(msg, self.getRange(callee.name));
                            }
                            const methodInfo = self.createMethodInfo(m, currentMethodName, isBase);
                            Transpiler.pickAccessInfo(accessInfo, methodInfo.accessInfo);
                        }
                    }
                }
            }
            typescript_1.default.forEachChild(node, node => vistMethodChild(node));
        }
        vistMethodChild(method);
        return accessInfo;
    }
    static pickAccessInfo(target, info) {
        return Object.keys(info).reduce((acc, current) => {
            if (info[current] === true) {
                Object.assign(acc, {
                    [current]: info[current]
                });
            }
            else if (Array.isArray(info[current]) && info[current].length > 0) {
                Object.assign(acc, {
                    [current]: [...new Set(acc[current].concat(info[current]))]
                });
            }
            return acc;
        }, target);
    }
    initAllMethodInfos() {
        if (this.currentbaseContract) {
            this.currentbaseContract.members.forEach(m => {
                if (Transpiler.isMethod(m)) {
                    this.createMethodInfo(m, m.name.getText(), true);
                }
            });
        }
        this._currentContract.members.forEach(m => {
            if (Transpiler.isMethod(m)) {
                this.createMethodInfo(m, m.name.getText(), false);
            }
        });
    }
    initAllPropInfos() {
        if (this.currentbaseContract) {
            this.currentbaseContract.members.forEach(m => {
                if (Transpiler.isProperty(m)) {
                    this.createPropInfo(m, true);
                }
            });
        }
        this._currentContract.members.forEach(m => {
            if (Transpiler.isProperty(m)) {
                this.createPropInfo(m, false);
            }
        });
    }
    createMethodInfo(m, currentMethodName, isBase) {
        //save methods info
        const cls = Transpiler.getClassDeclaration(m);
        const key = `${cls.name.getText()}.${m.name.getText()}`;
        if (!this.methodInfos.has(key)) {
            const methodInfo = {
                isPublic: Transpiler.isPublicMethod(m),
                isBase: isBase,
                accessInfo: this.createMethodAccessInfo(m, currentMethodName, isBase),
                name: m.name.getText(),
                codeSeparatorCount: 0
            };
            this.methodInfos.set(key, methodInfo);
        }
        return this.methodInfos.get(key);
    }
    createPropInfo(m, isBase) {
        const cls = Transpiler.getClassDeclaration(m);
        if (!cls) {
            throw new Error("No ClassDeclaration found!");
        }
        //save prop info
        const key = `${cls.name.getText()}.${m.name.getText()}`;
        if (!this.propInfos.has(key)) {
            const propInfo = {
                name: m.name.getText(),
                isState: Transpiler.isStateProperty(m),
                isStatic: Transpiler.isStaticProperty(m),
                isReadonly: Transpiler.isReadonlyProperty(m),
                isBase: isBase,
                isCTC: this.isCtcDeclaration(m),
                isHashed: m.type && this.isHashedMapOrHashedSet(m.type)
            };
            this.propInfos.set(key, propInfo);
        }
        return this.propInfos.get(key);
    }
    // TODO: don't support override now
    findMethodInfo(name) {
        const methodInfo = this.methodInfos.get(`${this.currentContractName}.${name}`);
        if (methodInfo) {
            return methodInfo;
        }
        if (this.currentbaseContract) {
            const methodInfo = this.methodInfos.get(`${this.currentbaseContractName}.${name}`);
            if (methodInfo) {
                return methodInfo;
            }
        }
        return undefined;
    }
    getCtxMethodInfos(isPublic = true) {
        return Array.from(this.methodInfos.values()).filter(info => info.accessInfo.accessCtx && info.isPublic === isPublic);
    }
    findPropInfo(name) {
        const propInfo = this.propInfos.get(`${this.currentContractName}.${name}`);
        if (propInfo) {
            return propInfo;
        }
        if (this.currentbaseContract) {
            const propInfo = this.propInfos.get(`${this.currentbaseContractName}.${name}`);
            if (propInfo) {
                return propInfo;
            }
        }
        return undefined;
    }
    getHashedPropInfos() {
        return Array.from(this.propInfos.values()).filter(info => info.isHashed);
    }
    getStatePropInfos() {
        return Array.from(this.propInfos.values()).filter(info => info.isState);
    }
    getPublicMethodCount() {
        let count = 0;
        this.methodInfos.forEach(info => {
            if (info.isPublic) {
                count++;
            }
        });
        return count;
    }
    /**
     * does the current contract have a method to access CTX
     * @returns
     */
    accessCtx() {
        let ret = false;
        this.methodInfos.forEach(info => {
            if (info.accessInfo.accessCtx) {
                ret = true;
            }
        });
        return ret;
    }
    accessTimelock() {
        let ret = false;
        this.methodInfos.forEach(info => {
            if (info.accessInfo.accessTimelock) {
                ret = true;
            }
        });
        return ret;
    }
    getCtxAccessInfo() {
        let merged = {};
        this.methodInfos.forEach(info => {
            if (info.accessInfo.accessCtx) {
                merged.accessVersion = merged.accessVersion || info.accessInfo.accessCtxInfo.accessVersion;
                merged.accessHashPrevouts = merged.accessHashPrevouts || info.accessInfo.accessCtxInfo.accessHashPrevouts;
                merged.accessHashSequence = merged.accessHashSequence || info.accessInfo.accessCtxInfo.accessHashSequence;
                merged.accessHashOutputs = merged.accessHashOutputs || info.accessInfo.accessCtxInfo.accessHashOutputs;
                merged.accessLocktime = merged.accessLocktime || info.accessInfo.accessCtxInfo.accessLocktime;
                merged.accessSequence = merged.accessSequence || info.accessInfo.accessCtxInfo.accessSequence;
                merged.accessSigHashType = merged.accessSigHashType || info.accessInfo.accessCtxInfo.accessSigHashType;
                merged.accessOutpoint = merged.accessOutpoint || info.accessInfo.accessCtxInfo.accessOutpoint;
                merged.accessScriptCode = merged.accessScriptCode || info.accessInfo.accessCtxInfo.accessScriptCode;
                merged.accessValue = merged.accessValue || info.accessInfo.accessCtxInfo.accessValue;
                merged.accessSerialize = merged.accessSerialize || info.accessInfo.accessCtxInfo.accessSerialize;
            }
        });
        return merged;
    }
    /**
   * does the current contract have a method to access Hasheded prop
   * @returns
   */
    accessHashededProp() {
        let ret = false;
        this.methodInfos.forEach(info => {
            if (info.isPublic && info.accessInfo.accessHashedProps.length > 0) {
                ret = true;
            }
        });
        return ret;
    }
    accessStateProp() {
        let ret = false;
        this.methodInfos.forEach(info => {
            if (info.isPublic && info.accessInfo.accessState) {
                ret = true;
            }
        });
        return ret;
    }
    accessChange() {
        let ret = false;
        this.methodInfos.forEach(info => {
            if (info.isPublic && info.accessInfo.accessChange) {
                ret = true;
            }
        });
        return ret;
    }
    accessPrevouts() {
        let ret = false;
        this.methodInfos.forEach(info => {
            if (info.isPublic && info.accessInfo.accessPrevouts) {
                ret = true;
            }
        });
        return ret;
    }
    shouldAutoAppendChangeAmount(node) {
        const methodInfo = this.findMethodInfo(node.name.getText());
        if (!methodInfo) {
            throw new types_1.UnknownError(`No method info found for \`${node.name.getText()}\``, this.getRange(node.name));
        }
        return methodInfo.isPublic && methodInfo.accessInfo.accessChange;
    }
    shouldAutoAppendPrevouts(node) {
        const methodInfo = this.findMethodInfo(node.name.getText());
        if (!methodInfo) {
            throw new types_1.UnknownError(`No method info found for \`${node.name.getText()}\``, this.getRange(node.name));
        }
        return methodInfo.isPublic && methodInfo.accessInfo.accessPrevouts;
    }
    static isPublicMethod(node) {
        if (typescript_1.default.isMethodDeclaration(node) &&
            (0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.PublicKeyword)
            && this.findDecorator(node, DecoratorName.Method)) {
            return true;
        }
        return false;
    }
    shouldAutoAppendSighashPreimage(node) {
        const hasSigHashPreimageParameters = node.parameters.find(p => { var _a; return ((_a = p.type) === null || _a === void 0 ? void 0 : _a.getText()) === 'SigHashPreimage'; });
        if (hasSigHashPreimageParameters) {
            return false;
        }
        const methodInfo = this.findMethodInfo(node.name.getText());
        if (!methodInfo) {
            throw new types_1.UnknownError(`No method info found for \`${node.name.getText()}\``, this.getRange(node.name));
        }
        return methodInfo.isPublic && (methodInfo.accessInfo.accessCtx || methodInfo.accessInfo.accessState);
    }
    shouldAutoAppendAccessPaths(node) {
        // have visited `SortedItemAccessTraceable` properties
        const methodInfo = this.findMethodInfo(node.name.getText());
        if (!methodInfo) {
            throw new types_1.UnknownError(`No method info found for \`${node.name.getText()}\``, this.getRange(node.name));
        }
        if (methodInfo.isPublic && methodInfo.accessInfo.accessHashedProps.length > 0) {
            return methodInfo.accessInfo.accessHashedProps;
        }
        return [];
    }
    transformParameter(node, toSection) {
        return toSection
            .appendWith(this, toSec => {
            if (!node.type) {
                throw new types_1.TranspileError(`Untransformable parameter: '${node.getText()}', all parameters should be typed explicitly`, this.getRange(node));
            }
            return this.transformEnclosingTypeNode(node.type, toSec);
        })
            .append(' ')
            .append(node.name.getText(), this.getCoordinates(node.name.getStart()));
    }
    transformStatement(node, toSection) {
        var _a, _b, _c;
        switch (node.kind) {
            case (typescript_1.default.SyntaxKind.Block): {
                return toSection
                    .append('{')
                    .appendWith(this, blockSec => {
                    node.statements.forEach((stmt) => {
                        blockSec
                            .append('\n')
                            .appendWith(this, stmtsSec => {
                            return this.transformStatement(stmt, stmtsSec);
                        });
                    });
                    return blockSec;
                }, true)
                    .append('\n}');
            }
            case (typescript_1.default.SyntaxKind.ExpressionStatement): {
                const s = node;
                if (s.expression.kind === typescript_1.default.SyntaxKind.CallExpression && /^super(\s*)\(.*\)/.test(s.expression.getText())) {
                    return toSection;
                }
                else if (s.expression.kind === typescript_1.default.SyntaxKind.CallExpression && /^console\./.test(s.expression.getText())) {
                    return toSection;
                }
                else if (s.expression.kind === typescript_1.default.SyntaxKind.CallExpression && /^this\.debug\./.test(s.expression.getText())) {
                    return toSection;
                }
                else if (s.expression.kind === typescript_1.default.SyntaxKind.CallExpression && /^this\.init\(/.test(s.expression.getText())) {
                    return toSection;
                }
                return this.transformExpression(s.expression, toSection).append(';');
            }
            case (typescript_1.default.SyntaxKind.VariableStatement): {
                const stmt = node;
                if (stmt.declarationList.declarations.length > 1) {
                    throw new types_1.TranspileError(`Untransformable statement: '${node.getText()}'`, this.getRange(node));
                }
                const d = stmt.declarationList.declarations[0];
                if (!d.initializer) {
                    throw new types_1.TranspileError(`Untransformable statement: '${node.getText()}'`, this.getRange(node));
                }
                if (this.isCtcDeclaration(d)) {
                    return toSection;
                }
                else {
                    // use `d.type` as type context node if it exists,
                    // otherwise use `d.initializer` to provide type context, so we can leverage the type inference.
                    if (d.type) {
                        return this.transformEnclosingTypeNode(d.type, toSection)
                            .append(` ${d.name.getText()}`, this.getCoordinates(d.name.getStart()))
                            .append(" = ")
                            .appendWith(this, toSec => {
                            return this.transformExpression(d.initializer, toSec);
                        })
                            .append(';');
                    }
                    const type = this._checker.getTypeAtLocation(d.initializer);
                    if (type.flags === typescript_1.default.TypeFlags.String) {
                        // fix https://github.com/sCrypt-Inc/scrypt-ts/issues/390
                        const coordinates = this.getCoordinates(d.initializer.getStart());
                        return toSection.append("bytes", coordinates)
                            .append(` ${d.name.getText()}`, this.getCoordinates(d.name.getStart()))
                            .append(" = ")
                            .appendWith(this, toSec => {
                            return this.transformExpression(d.initializer, toSec);
                        })
                            .append(';');
                    }
                    return this.transformEnclosingTypeNode(d.initializer, toSection)
                        .append(` ${d.name.getText()}`, this.getCoordinates(d.name.getStart()))
                        .append(" = ")
                        .appendWith(this, toSec => {
                        return this.transformExpression(d.initializer, toSec);
                    })
                        .append(';');
                }
            }
            case (typescript_1.default.SyntaxKind.ReturnStatement): {
                const s = node;
                if (!s.expression) {
                    // If only "return", then the method must be a void type.
                    // The return stmt gets handled elsewhere.
                    return toSection;
                }
                return toSection
                    .append(`return `, this.getCoordinates(s.getStart()))
                    .appendWith(this, toSec => {
                    return this.transformExpression(s.expression, toSec);
                })
                    .append(';');
            }
            case (typescript_1.default.SyntaxKind.IfStatement): {
                const s = node;
                toSection
                    .append(`if(`, this.getCoordinates(s.getStart()))
                    .appendWith(this, toSec => {
                    return this.transformExpression(s.expression, toSec);
                })
                    .append(`) `)
                    .appendWith(this, toSec => {
                    return this.transformStatement(s.thenStatement, toSec);
                });
                if (s.elseStatement) {
                    toSection.append(` else `)
                        .appendWith(this, toSec => {
                        return this.transformStatement(s.elseStatement, toSec);
                    });
                }
                return toSection;
            }
            case (typescript_1.default.SyntaxKind.ForStatement): {
                const s = node;
                let inductionVar = undefined;
                if (((_a = s.initializer) === null || _a === void 0 ? void 0 : _a.kind) === typescript_1.default.SyntaxKind.VariableDeclarationList) {
                    let ivDeclare = s.initializer.declarations[0];
                    // initializer expr must match `let $i = 0;`
                    if (ivDeclare.initializer.getText() === '0' || ivDeclare.initializer.getText() === '0n') {
                        inductionVar = ivDeclare.name;
                    }
                }
                if (!inductionVar) {
                    throw new types_1.TranspileError(`\`for\` statement in \`@method\` should have induction variable declaration as: 'for(let $i = 0; ...; ...)'`, this.getRange(s));
                }
                let loopCount = undefined;
                if (((_b = s.condition) === null || _b === void 0 ? void 0 : _b.kind) === typescript_1.default.SyntaxKind.BinaryExpression) {
                    let cond = s.condition;
                    // condition expr must match `$i < $constNum;`
                    const condVarName = cond.left.getText();
                    if (condVarName === inductionVar.getText()) {
                        if (cond.operatorToken.kind !== typescript_1.default.SyntaxKind.LessThanToken) {
                            throw new types_1.TranspileError(`\`for\` statement in \`@method\` should only have a \`<\`(lessthan) operator: 'for(...; $i < $constNum; ...)'`, this.getRange(cond.operatorToken));
                        }
                        if (this.isCtcExpression(cond.right)) {
                            if (this.isParameterNode(cond.right)) {
                                loopCount = cond.right.getText();
                            }
                            else {
                                loopCount = this.evalCtcExpression(cond.right);
                            }
                        }
                    }
                }
                if (loopCount === undefined) {
                    throw new types_1.TranspileError(`\`for\` statement in \`@method\` should have condition expression as: 'for(...; $i < $constNum; ...)'`, this.getRange(s));
                }
                let postIncIV = false;
                // incrementor expr must match `$i++`
                if (((_c = s.incrementor) === null || _c === void 0 ? void 0 : _c.kind) === typescript_1.default.SyntaxKind.PostfixUnaryExpression) {
                    let inc = s.incrementor;
                    if (inc.operator === typescript_1.default.SyntaxKind.PlusPlusToken
                        && inc.operand.getText() === inductionVar.getText()) {
                        postIncIV = true;
                    }
                }
                if (!postIncIV) {
                    throw new types_1.TranspileError(`\`for\` statement in \`@method\` should have incrementor expression as: 'for(...; ...; $i++)'`, this.getRange(s.incrementor));
                }
                return toSection
                    .append('loop (')
                    .append(loopCount)
                    .append(') : ')
                    .append(`${inductionVar.getText()} `, this.getCoordinates(inductionVar.getStart()))
                    .appendWith(this, toSec => {
                    return this.transformStatement(s.statement, toSec);
                });
            }
            default: {
                throw new types_1.TranspileError(`Untransformable statement: '${node.getText()}'`, this.getRange(node));
            }
        }
    }
    transformExpression(node, toSection) {
        const srcLoc = this.getCoordinates(node.getStart());
        const map = new Map();
        map.set(typescript_1.default.SyntaxKind.NumericLiteral, (node, toSection) => toSection.append(`${node.getText()}`, srcLoc));
        map.set(typescript_1.default.SyntaxKind.StringLiteral, (node, toSection) => this.transformStringLiteralExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.BigIntLiteral, (node, toSection) => this.transformBigIntLiteralExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.ArrayLiteralExpression, (node, toSection) => this.transformArrayLiteralExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.ObjectLiteralExpression, (node, toSection) => this.transformObjectLiteralExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.CallExpression, (node, toSection) => this.transformCallExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.Identifier, (node, toSection) => this.transformIdentifierExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.BinaryExpression, (node, toSection) => this.transformBinaryExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.PropertyAccessExpression, (node, toSection) => this.transformPropertyAccessExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.ArrowFunction, (node, toSection) => this.transformArrowFunctionExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.NewExpression, (node, toSection) => this.transformNewExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.ThisKeyword, (_node, toSection) => toSection.append("this", srcLoc));
        map.set(typescript_1.default.SyntaxKind.TrueKeyword, (_node, toSection) => toSection.append("true", srcLoc));
        map.set(typescript_1.default.SyntaxKind.FalseKeyword, (_node, toSection) => toSection.append("false", srcLoc));
        map.set(typescript_1.default.SyntaxKind.SuperKeyword, (_node, toSection) => toSection);
        map.set(typescript_1.default.SyntaxKind.ElementAccessExpression, (node, toSection) => this.transformElementAccessExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.ConditionalExpression, (node, toSection) => this.transformConditionalExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.ParenthesizedExpression, (node, toSection) => this.transformParenthesizedExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.PostfixUnaryExpression, (node, toSection) => this.transformPostfixUnaryExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.PrefixUnaryExpression, (node, toSection) => this.transformPrefixUnaryExpression(node, toSection));
        map.set(typescript_1.default.SyntaxKind.AsExpression, (node, toSection) => toSection.appendWith(this, toSec => this.transformExpression(node.expression, toSec)));
        const func = map.get(node.kind);
        if (func === undefined) {
            throw new types_1.TranspileError(`Untransformable expression kind ${typescript_1.default.SyntaxKind[node.kind]}: '${node.getText()}'`, this.getRange(node));
        }
        return func(node, toSection);
    }
    // transform the type enclosed in the node.
    transformEnclosingTypeNode(node, toSection) {
        const type = this._checker.getTypeAtLocation(node);
        return this.transformType(type, node, toSection);
    }
    // `typeStrCtx` is the type's literal name or the text of the node which encloses the type.
    transformType(type, node, toSection) {
        const typeStrCtx = node.getText();
        const coordinates = this.getCoordinates(node.getStart());
        switch (type.flags) {
            case (typescript_1.default.TypeFlags.Union + typescript_1.default.TypeFlags.Boolean): // This is the real internal type of `boolean`, it's a union of `true` and `false`
            case typescript_1.default.TypeFlags.BooleanLiteral:
            case typescript_1.default.TypeFlags.Boolean: {
                return toSection.append("bool", coordinates);
            }
            case (typescript_1.default.TypeFlags.Union + typescript_1.default.TypeFlags.EnumLiteral):
            case typescript_1.default.TypeFlags.BigIntLiteral:
            case typescript_1.default.TypeFlags.BigInt: {
                return toSection.append("int", coordinates);
            }
            case typescript_1.default.TypeFlags.NumberLiteral:
            case typescript_1.default.TypeFlags.Number: {
                if (typescript_1.default.isParameter(node.parent)) {
                    return toSection.append("static const int", coordinates);
                }
                throw new types_1.TranspileError(`Untransformable type \`number\` here, please use type \`bigint\` instead`, this.getRange(node));
            }
            case typescript_1.default.TypeFlags.Intersection:
            case typescript_1.default.TypeFlags.Object: {
                const typeString = this.type2ResolvedName(type);
                // for declared object literal type, like `x : {prop: number}`
                if (typeString === "__type") {
                    throw new types_1.TranspileError(`Untransformable literal object type: '${typeStrCtx}'`, this.getRange(node));
                }
                // for inferred object literal type, like `x = {prop: 1}`
                if (typeString === "__object") {
                    throw new types_1.TranspileError(`Untransformable literal object type: '${typeStrCtx}'`, this.getRange(node));
                }
                // for bigint & number wrapper
                if (typeString === "BigInt") {
                    return toSection.append('int', coordinates);
                }
                if (typeString === "Number") {
                    throw new types_1.TranspileError(`Untransformable type \`${typeStrCtx}\` here, please use type \`bigint\` instead`, this.getRange(node));
                }
                // for string wrapper
                if (typeString === "String") {
                    throw new types_1.TranspileError(`Untransformable type \`${typeStrCtx}\` here, please use type \`ByteString\` instead`, this.getRange(node));
                }
                // for boolean wrapper
                if (typeString === "Boolean") {
                    return toSection.append('bool', coordinates);
                }
                if (typeString === "HashedMap" || typeString === "HashedSet") {
                    const types = this._checker.getTypeArguments(type);
                    toSection.append(`${typeString}<`, coordinates);
                    types.forEach((t, index) => {
                        this.transformType(t, node, toSection);
                        if (index < types.length - 1) {
                            toSection.append(',');
                        }
                    });
                    toSection.append(`>`, coordinates);
                    return toSection;
                }
                if (typeString === "SortedItem") {
                    toSection.append(`${typeString}<`, coordinates);
                    this.transformType(type.aliasTypeArguments[0], node, toSection);
                    toSection.append(`>`, coordinates);
                    return toSection;
                }
                const isFixedArray = (type) => {
                    if (type.isUnionOrIntersection() && type.types.length === 2) {
                        const t1 = this._checker.typeToString(type.types[0]);
                        const t2 = this._checker.typeToString(type.types[1]);
                        if (t1.endsWith("[]") && /\{\slength:\s((\d+)|(number)|(any));\s\}/.test(t2)) {
                            return true;
                        }
                    }
                    return false;
                };
                if (isFixedArray(type)) {
                    const getBaseElemTypeAndLengths = (typeRef, arrLens) => {
                        if (typeRef.isUnionOrIntersection() && isFixedArray(typeRef)) {
                            const FixedArrayLenString = this._checker.typeToString(typeRef.types[1]);
                            let m = /(\d)+/.exec(FixedArrayLenString);
                            if (m) {
                                const fst = this._checker.getTypeArguments(typeRef.types[0]);
                                return getBaseElemTypeAndLengths(fst[0], arrLens.concat(parseInt(m[0])));
                            }
                            else {
                                throw new types_1.TranspileError(`Untransformable type \`Array\`, please use type \`FixedArray\` instead`, this.getRange(node));
                            }
                        }
                        else {
                            return { typeRef: typeRef, arrLens };
                        }
                    };
                    const getBaseElemTypeAndLengthsIncludeCTC = (tNode, arrLens) => {
                        const typeRef = this._checker.getTypeAtLocation(tNode);
                        if (typeRef.isUnionOrIntersection() && isFixedArray(typeRef)) {
                            const FixedArrayLenString = this._checker.typeToString(typeRef.types[1]);
                            if (typescript_1.default.isTypeReferenceNode(tNode)) {
                                if (FixedArrayLenString === "{ length: number; }" && tNode.typeArguments && tNode.typeArguments.length == 2 && typescript_1.default.isTypeQueryNode(tNode.typeArguments[1])) {
                                    if (this.isParameterNode(tNode.typeArguments[1].exprName)) {
                                        return getBaseElemTypeAndLengthsIncludeCTC(tNode.typeArguments[0], arrLens.concat(tNode.typeArguments[1].exprName.getText()));
                                    }
                                    else {
                                        throw new types_1.TranspileError(`Untransformable type \`Array\`, please use type \`FixedArray\` instead`, this.getRange(node));
                                    }
                                }
                                else if (FixedArrayLenString === "{ length: any; }" && tNode.typeArguments && tNode.typeArguments.length == 2 && typescript_1.default.isUnionTypeNode(tNode.typeArguments[1]) && typescript_1.default.isTypeQueryNode(tNode.typeArguments[1].types[0])) {
                                    if (this.isParameterNode(tNode.typeArguments[1].types[0].exprName)) {
                                        return getBaseElemTypeAndLengthsIncludeCTC(tNode.typeArguments[0], arrLens.concat(tNode.typeArguments[1].types[0].exprName.getText()));
                                    }
                                    else {
                                        throw new types_1.TranspileError(`Untransformable type \`Array\`, please use type \`FixedArray\` instead`, this.getRange(node));
                                    }
                                }
                                else {
                                    let m = /(\d)+/.exec(FixedArrayLenString);
                                    if (m) {
                                        if (tNode.typeArguments && tNode.typeArguments[0]) {
                                            return getBaseElemTypeAndLengthsIncludeCTC(tNode.typeArguments[0], arrLens.concat(parseInt(m[0])));
                                        }
                                        else {
                                            const fst = this._checker.getTypeArguments(typeRef.types[0]);
                                            return getBaseElemTypeAndLengths(fst[0], arrLens.concat(parseInt(m[0])));
                                        }
                                    }
                                    else {
                                        throw new types_1.TranspileError(`Untransformable type \`Array\`, please use type \`FixedArray\` instead`, this.getRange(node));
                                    }
                                }
                            }
                            else {
                                let m = /(\d)+/.exec(FixedArrayLenString);
                                if (m) {
                                    const fst = this._checker.getTypeArguments(typeRef.types[0]);
                                    return getBaseElemTypeAndLengths(fst[0], arrLens.concat(parseInt(m[0])));
                                }
                            }
                        }
                        else {
                            return { typeRef: typeRef, arrLens };
                        }
                    };
                    const { typeRef: baseElemType, arrLens } = getBaseElemTypeAndLengthsIncludeCTC(node, []);
                    this.transformType(baseElemType, node, toSection)
                        .append(`${arrLens.map(i => '[' + i + ']').join('')}`, coordinates);
                }
                else if (typeString === 'Array' || typeString === '[]') {
                    const isOldFixedArray = (typeRef) => {
                        var _a;
                        if (((_a = typeRef.typeArguments) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                            const typeString = this.type2ResolvedName(typeRef.typeArguments[0]);
                            return typeString.includes("Flavor") && typeString.includes("FixedArray");
                        }
                        else {
                            return false;
                        }
                    };
                    if (isOldFixedArray(type)) {
                        const getBaseElemTypeAndLengths = (typeRef, arrLens) => {
                            var _a, _b, _c;
                            if (((_a = typeRef.typeArguments) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                                let innerTypeRef = typeRef.typeArguments[0];
                                if (((_b = innerTypeRef.aliasTypeArguments) === null || _b === void 0 ? void 0 : _b.length) > 1) {
                                    const FixedArrayString = this.type2ResolvedName(innerTypeRef.aliasTypeArguments[1]);
                                    let m = /(\d)+/.exec(FixedArrayString);
                                    if (m) {
                                        return getBaseElemTypeAndLengths(innerTypeRef.aliasTypeArguments[0], arrLens.concat(parseInt(m[0])));
                                    }
                                    throw new types_1.TranspileError(`Untransformable type \`Array\`, please use type \`FixedArray\` instead`, this.getRange(node));
                                }
                                else {
                                    return getBaseElemTypeAndLengths(innerTypeRef, arrLens.concat((_c = typeRef.typeArguments) === null || _c === void 0 ? void 0 : _c.length));
                                }
                            }
                            else {
                                return { typeRef, arrLens };
                            }
                        };
                        const { typeRef: baseElemType, arrLens } = getBaseElemTypeAndLengths(type, []);
                        this.transformType(baseElemType, node, toSection)
                            .append(`${arrLens.map(i => '[' + i + ']').join('')}`, coordinates);
                        return toSection;
                    }
                    else {
                        throw new types_1.TranspileError(`Untransformable type \`Array\`, please use type \`FixedArray\` instead`, this.getRange(node));
                    }
                }
                else if (typeString.startsWith("[") && typeString.endsWith("]")) {
                    // built-in type `FixedArray` goes here.
                    const getBaseElemTypeAndLengths = (typeRef, arrLens) => {
                        var _a, _b;
                        if (((_a = typeRef.typeArguments) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                            let innerTypeRef = typeRef.typeArguments[0];
                            return getBaseElemTypeAndLengths(innerTypeRef, arrLens.concat((_b = typeRef.typeArguments) === null || _b === void 0 ? void 0 : _b.length));
                        }
                        else {
                            return { typeRef, arrLens };
                        }
                    };
                    const { typeRef: baseElemType, arrLens } = getBaseElemTypeAndLengths(type, []);
                    this.transformType(baseElemType, node, toSection)
                        .append(`${arrLens.map(i => '[' + i + ']').join('')}`, coordinates);
                }
                else {
                    const t = (0, utils_1.toBuildInsTypes)(typeString);
                    if (t) {
                        toSection.append(t, coordinates);
                    }
                    else {
                        // all user defined or std types go here.
                        toSection.append(typeString, coordinates);
                        if (type.symbol) {
                            this.saveSymbol(typeString, type.symbol);
                        }
                    }
                }
                break;
            }
            case typescript_1.default.TypeFlags.Any: {
                toSection.append('auto', coordinates);
                break;
            }
            case typescript_1.default.TypeFlags.String: {
                throw new types_1.TranspileError(`Untransformable type \`${typeStrCtx}\` here, please use type \`ByteString\` instead`, this.getRange(node));
            }
            default: {
                if (typescript_1.default.isTypeReferenceNode(node)) {
                    throw new types_1.TranspileError(`Untransformable type : '${typeStrCtx}'`, this.getRange(node));
                }
                else {
                    throw new types_1.TranspileError(`Untransformable type : '${typeStrCtx}', missing explicitly declared type`, this.getRange(node));
                }
            }
        }
        return toSection;
    }
    saveSymbol(symbolName, symbol) {
        // record type visiting if its symbol exits, for the purpose of `struct` & `import` generations.
        const BUILDINS_SYMBOS = ["SmartContract"];
        if (BUILDINS_SYMBOS.includes(symbolName)) {
            return;
        }
        let symbolSourceFile = this.findDeclarationFile(symbol);
        if (symbolSourceFile === this._srcFile) {
            this._localTypeSymbols.set(symbolName, symbol);
        }
        else {
            this._importedTypeSymbols.set(symbolName, symbol);
        }
    }
    transformModifiers(node, toSection) {
        let modifiers = typescript_1.default.getModifiers(node);
        if (modifiers) {
            modifiers.forEach(modifier => {
                switch (modifier.kind) {
                    case typescript_1.default.SyntaxKind.PublicKeyword: {
                        toSection.append('public ', this.getCoordinates(modifier.getStart()));
                        break;
                    }
                    case typescript_1.default.SyntaxKind.PrivateKeyword: {
                        toSection.append('private ', this.getCoordinates(modifier.getStart()));
                        break;
                    }
                    case typescript_1.default.SyntaxKind.ProtectedKeyword: {
                        // transform to nothing in scrypt
                        break;
                    }
                    case typescript_1.default.SyntaxKind.StaticKeyword: {
                        toSection.append('static ', this.getCoordinates(modifier.getStart()));
                        break;
                    }
                    case typescript_1.default.SyntaxKind.ReadonlyKeyword: {
                        toSection.append('const ', this.getCoordinates(modifier.getStart()));
                        break;
                    }
                    default: {
                        throw new types_1.TranspileError(`Untransformable modifier kind ${modifier.kind}: '${modifier.getText()}'`, this.getRange(modifier));
                    }
                }
            });
        }
        return toSection;
    }
    static findDecorator(node, decorator) {
        if (typescript_1.default.canHaveDecorators(node)) {
            return (typescript_1.default.getDecorators(node) || []).find((dec) => {
                return dec.expression.getText().match(new RegExp(`^${decorator}\((.*)?\)$`));
            });
        }
    }
    static isProperty(node) {
        if (typescript_1.default.isPropertyDeclaration(node)) {
            const decorator = Transpiler.findDecorator(node, DecoratorName.Prop);
            if (decorator) {
                return true;
            }
        }
        return false;
    }
    static isMethod(node) {
        if (typescript_1.default.isMethodDeclaration(node)) {
            const decorator = Transpiler.findDecorator(node, DecoratorName.Method);
            if (decorator) {
                return true;
            }
        }
        return false;
    }
    isNonProp(node) {
        if (typescript_1.default.isPropertyDeclaration(node)) {
            const decorator = Transpiler.findDecorator(node, DecoratorName.Prop);
            if (!decorator) {
                return true;
            }
        }
        return false;
    }
    isStaticReadOnlyNonProp(node) {
        if (typescript_1.default.isPropertyDeclaration(node)) {
            const decorator = Transpiler.findDecorator(node, DecoratorName.Prop);
            return !decorator && (0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.StaticKeyword) && (0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.ReadonlyKeyword);
        }
        return false;
    }
    static isStateProperty(node) {
        if (typescript_1.default.isPropertyDeclaration(node)) {
            const decorator = Transpiler.findDecorator(node, DecoratorName.Prop);
            if (decorator) {
                return /^prop\((true)+\)$/.test(decorator.expression.getText());
            }
        }
        return false;
    }
    static getClassDeclaration(node) {
        if (!node.parent) {
            return undefined;
        }
        if (typescript_1.default.isClassDeclaration(node.parent)) {
            return node.parent;
        }
        return Transpiler.getClassDeclaration(node.parent);
    }
    static getMethodDeclaration(node) {
        if (!node.parent) {
            return undefined;
        }
        if (typescript_1.default.isMethodDeclaration(node.parent)) {
            return node.parent;
        }
        return Transpiler.getMethodDeclaration(node.parent);
    }
    static getIfStatement(node) {
        if (!node.parent) {
            return undefined;
        }
        if (typescript_1.default.isIfStatement(node.parent)) {
            return node.parent;
        }
        return Transpiler.getIfStatement(node.parent);
    }
    findMethodDeclaration(name) {
        let m = this._currentContract.members.find(m => {
            return Transpiler.isMethod(m) && m.name.getText() === name;
        });
        if (m) {
            return m;
        }
        if (this.currentbaseContract) {
            return this.currentbaseContract.members.find(m => {
                return Transpiler.isMethod(m) && m.name.getText() === name;
            });
        }
        return undefined;
    }
    isNonPropReferences(node, name) {
        return node.members
            .filter(member => this.isNonProp(member))
            .map(m => {
            const p = m;
            return p.name.getText();
        }).includes(name);
    }
    allPropertyDeclaration(node) {
        if (typescript_1.default.isClassDeclaration(node)) {
            return node.members.filter(member => Transpiler.isProperty(member));
        }
        return [];
    }
    isCtcBinaryExpression(node) {
        const operators = [typescript_1.default.SyntaxKind.PlusToken, typescript_1.default.SyntaxKind.MinusToken, typescript_1.default.SyntaxKind.AsteriskToken];
        return operators.indexOf(node.operatorToken.kind) !== -1 && this.isCtcExpression(node.left) && this.isCtcExpression(node.right);
    }
    isCtcPrefixUnaryExpression(node) {
        const operators = [typescript_1.default.SyntaxKind.PlusToken, typescript_1.default.SyntaxKind.MinusToken];
        return operators.indexOf(node.operator) !== -1 && this.isCtcExpression(node.operand);
    }
    isCtcParenthesizedExpression(node) {
        return this.isCtcExpression(node.expression);
    }
    isCtcExpression(node) {
        if (!node || !typescript_1.default.isExpression(node)) {
            return false;
        }
        if ((0, utils_1.isNumberLiteralExpr)(node)) {
            return true;
        }
        if (typescript_1.default.isIdentifier(node) || typescript_1.default.isPropertyAccessExpression(node)) {
            return this.isCtcIdentifierOrProperty(node);
        }
        if (typescript_1.default.isBinaryExpression(node)) {
            return this.isCtcBinaryExpression(node);
        }
        if (typescript_1.default.isPrefixUnaryExpression(node)) {
            return this.isCtcPrefixUnaryExpression(node);
        }
        if (typescript_1.default.isParenthesizedExpression(node)) {
            return this.isCtcParenthesizedExpression(node);
        }
        return false;
    }
    isCtcDeclaration(node) {
        var _a;
        if (typescript_1.default.isPropertyDeclaration(node)) {
            if ((0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.StaticKeyword) && (0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.ReadonlyKeyword)) {
                return this.isCtcExpression(node['initializer']);
            }
            else if ((0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.ConstKeyword)) {
                return this.isCtcExpression(node['initializer']);
            }
        }
        else if (typescript_1.default.isVariableDeclaration(node) && typescript_1.default.getCombinedNodeFlags(node) === typescript_1.default.NodeFlags.Const) {
            return this.isCtcExpression(node['initializer']);
        }
        else if (typescript_1.default.isParameter(node) && node.type) {
            return ((_a = node.type) === null || _a === void 0 ? void 0 : _a.kind) === typescript_1.default.SyntaxKind.NumberKeyword;
        }
        return false;
    }
    isCtcIdentifierOrProperty(node) {
        const symbol = this._checker.getSymbolAtLocation(node);
        if (symbol) {
            if (symbol.valueDeclaration) {
                // local ctc
                return this.isCtcDeclaration(symbol.valueDeclaration);
            }
            // imported ctc
            return this.getImportedCtcValue(symbol) !== undefined;
        }
        return false;
    }
    isParameterNode(node) {
        const symbol = this._checker.getSymbolAtLocation(node);
        return symbol && symbol.valueDeclaration && typescript_1.default.isParameter(symbol.valueDeclaration);
    }
    evalCtcBinaryExpression(node) {
        const left = this.evalCtcExpression(node.left);
        const right = this.evalCtcExpression(node.right);
        const operator = node.operatorToken.getText();
        return eval(`BigInt("${left}") ${operator} BigInt("${right}")`).toString().replace('n', '');
    }
    evalCtcPrefixUnaryExpression(node) {
        const operand = this.evalCtcExpression(node.operand);
        const operator = node.operator === typescript_1.default.SyntaxKind.MinusToken ? '-' : '';
        return eval(`${operator}BigInt("${operand}")`).toString().replace('n', '');
    }
    evalCtcParenthesizedExpression(node) {
        return this.evalCtcExpression(node.expression);
    }
    evalCtcExpression(node) {
        if ((0, utils_1.isNumberLiteralExpr)(node)) {
            return eval(node.getText()).toString().replace('n', '');
        }
        if (typescript_1.default.isIdentifier(node) || typescript_1.default.isPropertyAccessExpression(node)) {
            const symbol = this._checker.getSymbolAtLocation(node);
            if (symbol.valueDeclaration) {
                return this.evalCtcExpression(symbol.valueDeclaration['initializer']);
            }
            const ctcValue = this.getImportedCtcValue(symbol);
            if (ctcValue) {
                return ctcValue;
            }
        }
        if (typescript_1.default.isBinaryExpression(node)) {
            return this.evalCtcBinaryExpression(node);
        }
        if (typescript_1.default.isPrefixUnaryExpression(node)) {
            return this.evalCtcPrefixUnaryExpression(node);
        }
        if (typescript_1.default.isParenthesizedExpression(node)) {
            return this.evalCtcParenthesizedExpression(node);
        }
        throw new types_1.TranspileError(`Cannot eval a non-CTC expression: '${node.getText()}'`, this.getRange(node));
    }
    getImportedCtcValue(symbol) {
        var _a, _b, _c;
        if (symbol.declarations) {
            let symbolDecl = ((_a = symbol.declarations) !== null && _a !== void 0 ? _a : [])[0];
            if (symbolDecl && typescript_1.default.isImportSpecifier(symbolDecl)) {
                const importDecl = symbolDecl.parent.parent.parent;
                if (typescript_1.default.isImportDeclaration(importDecl)) {
                    const moduleSpecifier = symbolDecl.parent.parent.parent.moduleSpecifier.getText().replace(/['"]/g, '');
                    const resolvedMoudle = typescript_1.default.resolveModuleName(moduleSpecifier, this._srcFile.fileName, this._compilerOptions, this._host);
                    let ctcExportFile = (_b = resolvedMoudle.resolvedModule) === null || _b === void 0 ? void 0 : _b.resolvedFileName;
                    if (ctcExportFile) {
                        const nodeType = this._checker.getTypeAtLocation(symbolDecl);
                        if (nodeType.isNumberLiteral()) {
                            return nodeType.value.toString().replace('n', '');
                        }
                        // for bigint literal
                        if (nodeType.isLiteral() && nodeType.value.base10Value) {
                            const negative = nodeType.value.negative ? '-' : '';
                            return negative + nodeType.value.base10Value.toString().replace('n', '');
                        }
                        return Transpiler.topCtcs.get(`${(0, utils_1.sha1)(ctcExportFile)}:${((_c = symbolDecl.propertyName) === null || _c === void 0 ? void 0 : _c.getText()) || symbolDecl.name.getText()}`);
                    }
                }
            }
        }
        return undefined;
    }
    transformCtcExpr(expr, toSection) {
        const coordinates = this.getCoordinates(expr.getStart());
        const ctcValue = this.evalCtcExpression(expr).toString().replace('n', '');
        toSection.append(ctcValue, coordinates);
        return toSection;
    }
    transformCtcNode(node, toSection) {
        if (this.isParameterNode(node)) {
            // ctc parameter
            const coordinates = this.getCoordinates(node.getStart());
            toSection.append(node.getText(), coordinates);
            return toSection;
        }
        const symbol = this._checker.getSymbolAtLocation(node);
        if (symbol && symbol.valueDeclaration) {
            // local ctc
            return this.transformCtcExpr(symbol.valueDeclaration['initializer'], toSection);
        }
        const ctcValue = this.getImportedCtcValue(symbol);
        if (ctcValue) {
            // imported ctc
            return toSection.append(ctcValue, this.getCoordinates(node.getStart()));
        }
        throw new types_1.TranspileError(`Cannot find ctc value: '${node.getText()}'`, this.getRange(node));
    }
    queryPropertyInitializedInStmt(node) {
        if (typescript_1.default.isExpressionStatement(node) && typescript_1.default.isBinaryExpression(node.expression)) {
            if (node.expression.operatorToken.getText() === '=' && typescript_1.default.isPropertyAccessExpression(node.expression.left) && node.expression.left.expression.getText() === 'this') {
                const symbol = this._checker.getSymbolAtLocation(node.expression.left.name);
                if (symbol && symbol.valueDeclaration && typescript_1.default.isPropertyDeclaration(symbol.valueDeclaration)) {
                    return symbol.valueDeclaration;
                }
            }
        }
        return undefined;
    }
    hasProperties(node) {
        return node.members.findIndex(m => typescript_1.default.isPropertyDeclaration(m) && typeof Transpiler.findDecorator(m, DecoratorName.Prop) !== 'undefined') > -1;
    }
    static isStaticProperty(node) {
        if (Transpiler.isProperty(node)) {
            return (0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.StaticKeyword);
        }
        return false;
    }
    static isReadonlyProperty(node) {
        if (Transpiler.isProperty(node)) {
            return (0, utils_1.hasModifier)(node, typescript_1.default.SyntaxKind.ReadonlyKeyword);
        }
        return false;
    }
    onlyHasStaticProperties(node) {
        return node.members.filter(m => typescript_1.default.isPropertyDeclaration(m)).every(m => {
            return Transpiler.findDecorator(m, DecoratorName.Prop) === undefined || Transpiler.isStaticProperty(m);
        });
    }
    hasConstructor(node) {
        return node.members.findIndex(m => typescript_1.default.isConstructorDeclaration(m)) > -1;
    }
    getConstructor(node) {
        return node.members.find(m => typescript_1.default.isConstructorDeclaration(m));
    }
    checkConstructor(node) {
        if (this.hasProperties(node)) {
            if (this.onlyHasStaticProperties(node)) {
                return;
            }
            if (!this.hasConstructor(node)) {
                throw new types_1.TranspileError(`Untransformable contract: a smart contract must have an explicit constructor if it has at least one @prop.`, this.getRange(node));
            }
            if (this.isInherited(node)) {
                this.checkSetConstructorStmt(this.getConstructor(node));
            }
            else {
                this.checkSuperStmt(this.getConstructor(node));
            }
        }
    }
    getImportedPath(fulSymbolPath) {
        return path.relative(path.dirname(this._scryptFullPath), fulSymbolPath);
    }
    resolvePackageDir(symbolFileFullPath) {
        let searchDir = path.dirname(symbolFileFullPath);
        do {
            const locatePath = path.join(searchDir, "package.json");
            if ((0, fs_1.existsSync)(locatePath)) {
                return path.dirname(locatePath);
            }
            if (path.join(searchDir, '..') === searchDir) {
                return undefined;
            }
            searchDir = path.join(searchDir, '..');
        } while (true);
    }
    saveThirdPartySymbol(symbol, symbolName, fullSymbolPath) {
        const symbolFile = this.findDeclarationFile(symbol);
        const symbolFileFullPath = symbolFile.fileName;
        const symbolPath = this.getRelativePathFromArtifacts(fullSymbolPath);
        let symbolDec = symbol.declarations[0];
        symbolDec = symbolDec.name || symbolDec;
        this._indexer.addSymbols([{
                name: symbolName,
                srcRange: {
                    fileName: symbolFileFullPath,
                    start: symbolFile.getLineAndCharacterOfPosition(symbolDec.getStart()),
                    end: symbolFile.getLineAndCharacterOfPosition(symbolDec.getEnd())
                }
            }], symbolPath);
    }
    saveLocalSymbol(symbol, symbolName, fullSymbolPath) {
        const symbolFile = this.findDeclarationFile(symbol);
        const symbolFileFullPath = symbolFile.fileName;
        const symbolPath = this.getRelativePathFromTsRoot(fullSymbolPath);
        let symbolDec = symbol.declarations[0];
        symbolDec = symbolDec.name || symbolDec;
        this._indexer.addSymbols([{
                name: symbolName,
                srcRange: {
                    fileName: symbolFileFullPath,
                    start: symbolFile.getLineAndCharacterOfPosition(symbolDec.getStart()),
                    end: symbolFile.getLineAndCharacterOfPosition(symbolDec.getEnd())
                }
            }], symbolPath);
    }
    transformImports(allmissSym) {
        let importsSection = new EmittedSection();
        const imports = new Set();
        const missSymbols = new Map();
        Array.from(this._importedTypeSymbols.entries()).forEach(entry => {
            const symbolName = entry[0];
            const symbol = entry[1];
            const symbolFile = this.findDeclarationFile(symbol);
            const symbolFileFullPath = symbolFile.fileName;
            const isFromBuiltins = /\/scrypt-ts\/(src|dist)\/smart-contract\/builtins\/.+$/.test(symbolFileFullPath);
            if (isFromBuiltins)
                return; // skip import all builtin symbols
            if (this.isFromThirdParty(symbolFileFullPath)) {
                let thirdPartyBaseDir = this.resolvePackageDir(symbolFileFullPath);
                if (!thirdPartyBaseDir) {
                    importsSection.errors.push(new types_1.TranspileError(`Invalid symbol '${symbolName}', missing \`package.json\``, {
                        fileName: symbolFileFullPath,
                        start: { line: -1, character: -1 },
                        end: { line: -1, character: -1 }
                    }));
                    return;
                }
                const thirdPartyIndexFile = indexerReader_1.IndexerReader.queryIndexFile(path.dirname(symbolFileFullPath), thirdPartyBaseDir);
                if (!thirdPartyIndexFile) {
                    const message = symbolName === 'ScriptContext' ?
                        "`ScriptContext` is not allowed to be defined in the contract" :
                        `Invalid symbol '${symbolName}', missing \`scrypt.index.json\` in the third party root directory ${thirdPartyBaseDir}`;
                    importsSection.errors.push(new types_1.TranspileError(message, {
                        fileName: symbolFileFullPath,
                        start: { line: -1, character: -1 },
                        end: { line: -1, character: -1 }
                    }));
                    return;
                }
                else {
                    const thirdPartyIndexer = new indexerReader_1.IndexerReader(thirdPartyIndexFile);
                    const thirdPartyFullPath = thirdPartyIndexer.getFullPath(symbolName);
                    if (!thirdPartyFullPath) {
                        importsSection.errors.push(new types_1.TranspileError(`Invalid symbol '${symbolName}', missing index info of symbol ${symbolName} in the third party indexer file '${thirdPartyIndexFile}'`, {
                            fileName: symbolFileFullPath,
                            start: { line: -1, character: -1 },
                            end: { line: -1, character: -1 }
                        }));
                        return;
                    }
                    else {
                        this.saveThirdPartySymbol(symbol, symbolName, thirdPartyFullPath);
                        imports.add(this.getImportedPath(thirdPartyFullPath));
                    }
                }
            }
            else {
                // local imports
                let symbolPath = this._indexer.getFullPath(symbolName);
                if (symbolPath) {
                    imports.add(this.getImportedPath(symbolPath));
                }
                else {
                    this.saveLocalSymbol(symbol, symbolName, symbolFileFullPath);
                    symbolPath = this._indexer.getFullPath(symbolName);
                    imports.add(this.getImportedPath(symbolPath));
                    const symbols = missSymbols.get(symbolFile) || new Map();
                    symbols.set(symbolName, symbol);
                    missSymbols.set(symbolFile, symbols);
                }
            }
        });
        // merge all miss import local symbols
        if (missSymbols.size > 0) {
            missSymbols.forEach((value, key) => {
                if (allmissSym.has(key)) {
                    const map = allmissSym.get(key);
                    value.forEach((v, k) => {
                        map.set(k, v);
                    });
                }
                else {
                    allmissSym.set(key, value);
                }
            });
            // generate scrypt file for missing Imported local symbol
            allmissSym.forEach((symbols, symbolFile) => {
                let transpiler = new Transpiler(symbolFile, this._host, this._checker, this._tsRootDir, this._scryptOutDir, this._indexer, this._compilerOptions);
                transpiler.setLocalSymbols(symbols);
                transpiler.transform(allmissSym);
            });
        }
        imports.forEach(import_ => {
            importsSection
                .append("import ")
                .append(`"${import_.replaceAll('\\', '/')}"`)
                .append(';');
        });
        return importsSection;
    }
    transformTypeLiteralAndInterfaces() {
        let structSecs = [];
        let enumSecs = [];
        this._localTypeSymbols.forEach((symbol, symbolTypeName) => {
            let symbolDec = symbol.declarations[0];
            if ([typescript_1.default.SyntaxKind.TypeLiteral, typescript_1.default.SyntaxKind.InterfaceDeclaration].includes(symbolDec.kind)) {
                let stSec = new EmittedSection()
                    .appendWith(this, stSec => {
                    return stSec
                        .append('\nstruct ')
                        .append(`${symbolTypeName} {`, this.getCoordinates(symbolDec.getStart()))
                        .appendWith(this, fieldsSec => {
                        symbol.members.forEach((memSymbol) => {
                            fieldsSec
                                .append('\n')
                                .appendWith(this, fieldSec => {
                                return this.transformPropertySignature(memSymbol.valueDeclaration, fieldSec);
                            });
                        });
                        return fieldsSec;
                    }, true)
                        .append('\n}');
                });
                structSecs.push(stSec);
            }
            else if (typescript_1.default.isEnumDeclaration(symbolDec)) {
                const enumDeclaration = symbolDec;
                let enumSec = new EmittedSection()
                    .appendWith(this, enumSec => {
                    return enumSec
                        .append('\nlibrary ')
                        .append(`${symbolTypeName} {`, this.getCoordinates(symbolDec.getStart()))
                        .appendWith(this, enumMembersSec => {
                        let prevEnumMemValue = -1;
                        enumDeclaration.members.forEach((enumMember) => {
                            enumMembersSec
                                .append('\n')
                                .append(`static const int ${enumMember.name.getText()} = `)
                                .appendWith(this, enumMemberSec => {
                                if (enumMember.initializer) {
                                    const type = this._checker.getTypeAtLocation(enumMember.initializer);
                                    if (type.flags !== typescript_1.default.TypeFlags.NumberLiteral) {
                                        throw new types_1.TranspileError(`Untransformable enum member: '${symbolTypeName}.${enumMember.name.getText()}', only allowed number literal in enum`, this.getRange(enumMember));
                                    }
                                    prevEnumMemValue = parseInt(enumMember.initializer.getText());
                                    return this.transformExpression(enumMember.initializer, enumMemberSec);
                                }
                                else {
                                    prevEnumMemValue++;
                                    enumMemberSec.append(`${prevEnumMemValue}`);
                                }
                                return enumMemberSec;
                            })
                                .append(';');
                        });
                        return enumMembersSec;
                    }, true)
                        .append('\n}');
                });
                enumSecs.push(enumSec);
            }
        });
        return EmittedSection.join(...structSecs.concat(enumSecs));
    }
    toScryptBinary(node, operator) {
        switch (operator) {
            case "==":
            case "!=":
            case "+":
            case "-":
            case "*":
            case "/":
            case "%":
            case "+=":
            case "-=":
            case "*=":
            case "/=":
            case "%=":
            case "<":
            case ">":
            case "<=":
            case ">=":
            case "&&":
            case "||":
            case "=":
                return operator;
            case "===":
                return "==";
            case "!==":
                return "!=";
            default:
                throw new types_1.TranspileError(`Untransformable binary operator: '${operator}'`, this.getRange(node));
        }
    }
    // SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.TildeToken | SyntaxKind.ExclamationToken
    toScryptUnary(node, operator) {
        switch (operator) {
            case typescript_1.default.SyntaxKind.PlusPlusToken:
                return "++";
            case typescript_1.default.SyntaxKind.MinusMinusToken:
                return "--";
            case typescript_1.default.SyntaxKind.MinusToken:
                return "-";
            case typescript_1.default.SyntaxKind.ExclamationToken:
                return "!";
            default:
                throw new types_1.TranspileError(`Untransformable prefix unary operator kind ${typescript_1.default.SyntaxKind[operator]} in: ${node.getText()}`, this.getRange(node));
        }
    }
    type2ResolvedName(type) {
        var _a;
        // for basic types
        if (!type.symbol) {
            return this._checker.typeToString(type, undefined, typescript_1.default.TypeFormatFlags.UseAliasDefinedOutsideCurrentScope);
        }
        let typeName = type.symbol.escapedName.toString();
        // get scrypt struct name which might be a type alias or interface
        if (typeName === "__type") {
            return ((_a = type.aliasSymbol) === null || _a === void 0 ? void 0 : _a.escapedName.toString()) || typeName;
        }
        return typeName;
    }
    getResolvedTypeName(node) {
        const type = this._checker.getTypeAtLocation(node);
        return this.type2ResolvedName(type);
    }
    isHashedMapOrHashedSet(node) {
        const typeName = this.getResolvedTypeName(node);
        return ["HashedMap", "HashedSet"].includes(typeName);
    }
    // check if a call expression is a method call to a certain class's instance.
    isCertainClassPropertyAccessExpr(expr, clazz) {
        const objExpr = expr.expression;
        return this.getResolvedTypeName(objExpr) === clazz;
    }
    // transform method calls from `SortedItemAccessTraceable`s
    transformSortedItemAccessTraceableCall(node, toSection, accessMethods) {
        const methodExpr = node.expression;
        const objExpr = methodExpr.expression;
        const nameExpr = methodExpr.name;
        const argExprs = node.arguments;
        const methodName = nameExpr.getText();
        // insert action should be wrapped with `require`, i.e instance.add(xxx) -> require(instance.add(xxx))
        const autoAppendRequires = ['add', 'set'];
        if (autoAppendRequires.includes(methodName)) {
            toSection.append("require(");
        }
        toSection
            .appendWith(this, toSec => {
            return this.transformExpression(methodExpr, toSec);
        })
            .append("(")
            .appendWith(this, toSec => {
            argExprs.forEach((arg, index) => {
                if (accessMethods.includes(methodName) && index === 0) {
                    // transform the first argument to `SortedItem`: arg -> {arg, this.xxx_reader.readInt()}
                    toSec
                        .append("{")
                        .appendWith(this, sec => {
                        return this.transformExpression(arg, sec);
                    })
                        .append(`, this.${InjectedPropAccessPathReaderPrefix}${objExpr.getText().replace("this.", "")}.readInt()`)
                        .append("}");
                }
                else {
                    toSec.appendWith(this, sec => {
                        return this.transformExpression(arg, sec);
                    });
                }
                if (index < argExprs.length - 1) {
                    toSec.append(", ");
                }
            });
            return toSec;
        })
            .append(")");
        // insert action should be wrapped with `require()`
        if (autoAppendRequires.includes(methodName)) {
            toSection.append(")");
        }
        return toSection;
    }
    transformStringLiteralExpression(node, toSection) {
        if (node.parent.kind === typescript_1.default.SyntaxKind.CallExpression) {
            const srcLoc = this.getCoordinates(node.getStart());
            const parent = node.parent;
            if ((0, utils_1.allowByteStringLiteral)(parent)) {
                if (parent.expression.getText() === "toByteString") {
                    let literal = parent.arguments[0].getText();
                    literal = literal.substring(1, literal.length - 1);
                    if (parent.arguments.length == 1) {
                        // one argument --> hex literal
                        if (!/^([0-9a-fA-F]{2})*$/.test(literal)) {
                            throw new types_1.TranspileError(`\`${literal}\` is not a valid hex literal`, this.getRange(node));
                        }
                        toSection.append(`b'${literal}'`, srcLoc);
                    }
                    else {
                        // two arguments
                        let isUtf8 = parent.arguments[1].getText();
                        if (isUtf8 === 'false') {
                            // hex literal
                            if (!/^([0-9a-fA-F]{2})*$/.test(literal)) {
                                throw new types_1.TranspileError(`\`${literal}\` is not a valid hex literal`, this.getRange(node));
                            }
                            toSection.append(`b'${literal}'`, srcLoc);
                        }
                        else if (isUtf8 === 'true') {
                            // utf8 literal
                            // Auto escape double quotes.
                            let escaped = literal.replace(/"/g, '\\"');
                            toSection.append(`"${escaped}"`, srcLoc);
                        }
                        else {
                            throw new types_1.TranspileError('Only boolean literal can be passed to the second parameter of `toByteString`', this.getRange(node));
                        }
                    }
                }
                else {
                    try {
                        (0, utils_1.checkByteStringLiteral)(node);
                    }
                    catch (error) {
                        throw new types_1.TranspileError(error.message, this.getRange(node));
                    }
                }
            }
            else {
                throw new types_1.TranspileError(`String literal ${node.getText()} is not allowed here, please use \`toByteString\` instead`, this.getRange(node));
            }
        }
        else {
            throw new types_1.TranspileError(`String literal ${node.getText()} is not allowed here, please use \`toByteString\` instead`, this.getRange(node));
        }
        return toSection;
    }
    transformBigIntLiteralExpression(node, toSection) {
        let text = node.getText();
        text = text.replaceAll(/[_n]/g, '');
        return toSection.append(`${text}`, this.getCoordinates(node.getStart()));
    }
    transformArrayLiteralExpression(node, toSection) {
        const e = node;
        return toSection
            .append("[")
            .appendWith(this, toSec => {
            e.elements.forEach((arg, index) => {
                toSec
                    .appendWith(this, toSec => this.transformExpression(arg, toSec))
                    .append(index < e.elements.length - 1 ? ", " : "");
            });
            return toSec;
        })
            .append("]");
    }
    transformObjectLiteralExpression(node, toSection) {
        const e = node;
        toSection.append("{", this.getCoordinates(e.getStart()));
        const type = this._checker.getContextualType(e);
        if (type) {
            let members = [];
            type.getProperties().forEach(property => members.push(property.getName()));
            members.forEach((member, index) => {
                const property = e.properties.find(property => property.name.getText() === member);
                if (property) {
                    const _property = property;
                    if (_property.initializer) {
                        toSection
                            .appendWith(this, toSec => this.transformExpression(_property.initializer, toSec))
                            .append(index < members.length - 1 ? ", " : "");
                    }
                    else {
                        toSection
                            .append(_property.name.getText())
                            .append(index < members.length - 1 ? ", " : "");
                    }
                }
                else {
                    const structname = type.symbol === undefined
                        ? this._checker.typeToString(type, undefined, typescript_1.default.TypeFormatFlags.UseAliasDefinedOutsideCurrentScope)
                        : (type.aliasSymbol === undefined ? type.symbol.escapedName : type.aliasSymbol.escapedName).toString();
                    throw new types_1.TranspileError(`field not found for struct '${structname}': '${property.getText()}'`, this.getRange(e));
                }
            });
        }
        else {
            throw new types_1.TranspileError(`Untransformable expression: '${e.getText()}'`, this.getRange(e));
        }
        return toSection.append("}");
    }
    transformIdentifierExpression(node, toSection) {
        const nodeType = this._checker.getTypeAtLocation(node);
        if (nodeType.symbol && [typescript_1.default.SymbolFlags.Class, typescript_1.default.SymbolFlags.ConstEnum, typescript_1.default.SymbolFlags.RegularEnum].includes(nodeType.symbol.getFlags())) {
            this.saveSymbol(nodeType.symbol.getName(), nodeType.symbol);
        }
        if (this.isCtcIdentifierOrProperty(node)) {
            return this.transformCtcNode(node, toSection);
        }
        if (this.isTranspilingConstructor(node) && this.isTranspilingBaseContract(node)) {
            const mapedNode = this._constructorParametersMap.get(node.getText());
            if (mapedNode) {
                if (typescript_1.default.isParameter(mapedNode)) {
                    toSection.append(mapedNode.name.getText(), this.getCoordinates(node.getStart()));
                    return toSection;
                }
                else if (typescript_1.default.isExpression(mapedNode)) {
                    toSection.appendWith(this, toSec => this.transformExpression(mapedNode, toSec));
                    return toSection;
                }
            }
        }
        toSection.append(node.getText(), this.getCoordinates(node.getStart()));
        return toSection;
    }
    isBooleanType(node) {
        return ['true', 'false', 'never', 'boolean'].indexOf(this.getResolvedTypeName(node)) !== -1;
    }
    transformBinaryExpression(node, toSection) {
        const e = node;
        const operator = this.toScryptBinary(e, e.operatorToken.getText());
        if (e.operatorToken.getText() === '&&' || e.operatorToken.getText() === '||') {
            // require both operands are boolean type
            if (!this.isBooleanType(e.left) || !this.isBooleanType(e.right)) {
                throw new types_1.TranspileError(`\`${node.getText()}\` is not allowed, both operands of \`${e.operatorToken.getText()}\` must be boolean type`, this.getRange(node));
            }
        }
        const srcLoc = this.getCoordinates(e.getStart());
        return this.transformBinaryOperation(operator, e.left, e.right, srcLoc, toSection);
    }
    transformSpecialPropertyAccessExpression(node, toSection) {
        const text = node.getText().replaceAll("?", "");
        let isSpecial = true;
        switch (text) {
            case "SigHash.ALL":
                toSection.append("SigHash.ALL | SigHash.FORKID", this.getCoordinates(node.name.getStart()));
                break;
            case "SigHash.NONE":
                toSection.append("SigHash.NONE | SigHash.FORKID", this.getCoordinates(node.name.getStart()));
                break;
            case "SigHash.SINGLE":
                toSection.append("SigHash.SINGLE | SigHash.FORKID", this.getCoordinates(node.name.getStart()));
                break;
            case "SigHash.ANYONECANPAY_ALL":
                toSection.append("SigHash.ALL | SigHash.ANYONECANPAY | SigHash.FORKID", this.getCoordinates(node.name.getStart()));
                break;
            case "SigHash.ANYONECANPAY_NONE":
                toSection.append("SigHash.NONE | SigHash.ANYONECANPAY | SigHash.FORKID", this.getCoordinates(node.name.getStart()));
                break;
            case "SigHash.ANYONECANPAY_SINGLE":
                toSection.append("SigHash.SINGLE | SigHash.ANYONECANPAY | SigHash.FORKID", this.getCoordinates(node.name.getStart()));
                break;
            case "this.changeAmount":
                toSection.append(`this.${InjectedChangeProp}.amount`);
                break;
            case "this.ctx":
                throw new types_1.TranspileError(`Direct access to \`this.ctx\` is prohibited, only access to \`this.ctx.*\` is allowed, such as: \`this.ctx.hashOutputs\` or \`this.ctx.sigHashType\``, this.getRange(node));
                break;
            case "this.prevouts":
                toSection.append(`this.${InjectedPrevoutsProp}`);
                break;
            case "this.changeAddress":
                toSection.append(`this.${InjectedChangeProp}.address`);
                break;
            case "this.ctx.version":
                toSection.append(`this.${InjectedCtxVerionProp}`);
                break;
            case "this.ctx.hashPrevouts":
                toSection.append(`this.${InjectedCtxHashPrevoutsProp}`);
                break;
            case "this.ctx.hashSequence":
                toSection.append(`this.${InjectedCtxHashSequenceProp}`);
                break;
            case "this.ctx.sequence":
                toSection.append(`this.${InjectedCtxSequenceProp}`);
                break;
            case "this.ctx.hashOutputs":
                toSection.append(`this.${InjectedCtxHashOutputsProp}`);
                break;
            case "this.ctx.locktime":
                toSection.append(`this.${InjectedCtxLocktimeProp}`);
                break;
            case "this.ctx.sigHashType":
                toSection.append(`this.${InjectedCtxSigHashTypeProp}`);
                break;
            case "this.ctx.utxo.value":
                toSection.append(`this.${InjectedCtxValueProp}`);
                break;
            case "this.ctx.utxo.script":
                toSection.append(`this.${InjectedCtxScriptCodeProp}`);
                break;
            case "this.ctx.utxo.outpoint.txid":
                toSection.append(`this.${InjectedCtxOutpointTxidProp}`);
                break;
            case "this.ctx.utxo.outpoint.outputIndex":
                toSection.append(`this.${InjectedCtxOutpointOutputIndexProp}`);
                break;
            default:
                {
                    isSpecial = false;
                }
        }
        return isSpecial;
    }
    transformCTCPropertyAccessExpression(node, toSection) {
        if (typescript_1.default.isIdentifier(node.name) && typescript_1.default.isIdentifier(node.expression)) {
            if (this.isCtcIdentifierOrProperty(node)) {
                this.transformCtcNode(node, toSection);
                return true;
            }
        }
        return false;
    }
    transformHashedPropertyAccessExpression(node, toSection) {
        const isHashedMapPropAccess = this.isCertainClassPropertyAccessExpr(node, 'HashedMap');
        const isHashedSetPropAccess = this.isCertainClassPropertyAccessExpr(node, 'HashedSet');
        if (isHashedMapPropAccess || isHashedSetPropAccess) {
            const objExpr = node.expression;
            const nameExpr = node.name;
            const propName = node.name.getText();
            const hashedPropInfo = this.getHashedPropInfos();
            if (!hashedPropInfo.find(info => info.name === objExpr.getText().replace("this.", ""))) {
                throw new types_1.TranspileError(`\`${propName}\` can not be called on \`${objExpr.getText()}\` inside @method, it can only be called directly on property like \`this.myMap\``, this.getRange(nameExpr));
            }
            if (this.isTranspilingConstructor(node)) {
                const whiteList = ['clear', 'size'];
                if (!whiteList.includes(propName)) {
                    throw new types_1.TranspileError(`Only these fields of \`${isHashedMapPropAccess ? 'HashedMap' : 'HashedSet'}\` can be called inside constructor: ${whiteList.join(', ')}`, this.getRange(nameExpr));
                }
            }
            else {
                const whiteList = isHashedMapPropAccess ? ['canGet', 'set', 'delete', 'has', 'clear', 'size'] : ['add', 'has', 'delete', 'clear', 'size'];
                if (!whiteList.includes(propName)) {
                    throw new types_1.TranspileError(`Only these fields of \`${isHashedMapPropAccess ? 'HashedMap' : 'HashedSet'}\` can be called inside @method: ${whiteList.join(', ')}`, this.getRange(nameExpr));
                }
            }
            toSection
                .appendWith(this, toSec => this.transformExpression(node.expression, toSec))
                .append(`.${node.name.getText()}`, this.getCoordinates(node.name.getStart()));
            if (node.name.getText() === "size") {
                // make `instance.size` to `instance.size()`
                toSection.append("()");
            }
            return true;
        }
        return false;
    }
    transformPropertyAccessExpression(node, toSection) {
        if (this.transformSpecialPropertyAccessExpression(node, toSection)) {
            return toSection;
        }
        if (this.transformCTCPropertyAccessExpression(node, toSection)) {
            return toSection;
        }
        if (this.transformHashedPropertyAccessExpression(node, toSection)) {
            return toSection;
        }
        const name = node.name.getText();
        const cls = Transpiler.getClassDeclaration(node);
        if (this.isNonPropReferences(cls, name)) {
            throw new types_1.TranspileError(`Cannot access Non-Prop property '${name}' in a \`@method()\` function`, this.getRange(node));
        }
        if (typescript_1.default.isIdentifier(node.expression)) {
            const leftSide = node.expression.getText();
            if (leftSide === this.currentbaseContractName) {
                toSection
                    .append(`${this.currentContractName}.${node.name.getText()}`, this.getCoordinates(node.name.getStart()));
                return toSection;
            }
        }
        toSection
            .appendWith(this, toSec => this.transformExpression(node.expression, toSec))
            .append(`.${node.name.getText()}`, this.getCoordinates(node.name.getStart()));
        return toSection;
    }
    transformArrowFunctionExpression(node, toSection) {
        const e = node;
        if (typescript_1.default.isBlock(e.body)) {
            if (e.parameters.length > 1) {
                throw new types_1.TranspileError(`Untransformable expression kind ${typescript_1.default.SyntaxKind[e.kind]}: '${e.getText()}'`, this.getRange(e));
            }
            if (e.parameters.length === 1) {
                toSection.append(` : ${e.parameters[0].name.getText()}`);
            }
            toSection.append(" ");
            return this.transformStatement(e.body, toSection);
        }
        throw new types_1.TranspileError(`Untransformable expression kind ${typescript_1.default.SyntaxKind[e.kind]}: '${e.getText()}'`, this.getRange(e));
    }
    transformNewExpression(node, toSection) {
        var _a;
        const e = node;
        const clsText = e.expression.getText();
        const scryptType = (0, utils_1.getBuiltInType)(clsText);
        if (scryptType) {
            toSection
                .append(scryptType, this.getCoordinates(e.getStart()))
                .append("(");
            if (clsText === "SigHashType" && e.arguments[0].kind) {
                const t = parseInt(e.arguments[0].getText());
                toSection.append(`b'${(0, utils_1.number2hex)(t)}'`);
            }
            else {
                e.arguments.forEach((arg, index) => {
                    toSection
                        .appendWith(this, toSec => this.transformExpression(arg, toSec))
                        .append(index < e.arguments.length - 1 ? ", " : "");
                });
            }
            toSection.append(")");
        }
        else {
            const type = this.getResolvedType(e.expression);
            const classDec = (_a = type.getSymbol()) === null || _a === void 0 ? void 0 : _a.declarations[0];
            if (this.isHashedMapOrHashedSet(e.expression)) {
                throw new types_1.TranspileError(`\`HashedMap\` or \`HashedSet\` can not be initialized inside a @method`, this.getRange(e));
            }
            // if this extends `SmartContract` or `SmartLibrary`
            if (this.isLibrary(classDec)) {
                toSection
                    .append('new ')
                    .append(e.expression.getText(), this.getCoordinates(e.expression.getStart()))
                    .append('(')
                    .appendWith(this, toSec => {
                    e.arguments.forEach((arg, index) => {
                        toSec
                            .appendWith(this, ts => this.transformExpression(arg, ts))
                            .append(index < e.arguments.length - 1 ? ", " : "");
                    });
                    return toSec;
                })
                    .append(')');
            }
            else if (this.isContract(classDec)) {
                throw new types_1.TranspileError(`contract \`${e.expression.getText()}\` can not be initialized inside a @method, only supports instantiation of library`, this.getRange(e));
            }
            else {
                throw new types_1.TranspileError(`Untransformable expression kind ${typescript_1.default.SyntaxKind[e.kind]}: '${e.getText()}'`, this.getRange(e));
            }
        }
        return toSection;
    }
    transformElementAccessExpression(node, toSection) {
        const e = node;
        if (this.getResolvedTypeName(e.expression) === 'ByteString') {
            // ByteString[] is not allowed
            throw new types_1.TranspileError(`\`${node.getText()}\` is not allowed here, use \`slice(ByteString, bigint, bigint)\` instead`, this.getRange(e));
        }
        return toSection
            .appendWith(this, toSec => this.transformExpression(e.expression, toSec))
            .append("[")
            .appendWith(this, toSec => this.transformExpression(e.argumentExpression, toSec))
            .append("]");
    }
    transformConditionalExpression(node, toSection) {
        const e = node;
        return toSection
            .appendWith(this, toSec => this.transformExpression(e.condition, toSec))
            .append(" ? ")
            .appendWith(this, toSec => this.transformExpression(e.whenTrue, toSec))
            .append(" : ")
            .appendWith(this, toSec => this.transformExpression(e.whenFalse, toSec));
    }
    transformParenthesizedExpression(node, toSection) {
        const e = node;
        return toSection
            .append("(")
            .appendWith(this, toSec => this.transformExpression(e.expression, toSec))
            .append(")");
    }
    transformPostfixUnaryExpression(node, toSection) {
        const e = node;
        return toSection
            .appendWith(this, toSec => this.transformExpression(e.operand, toSec))
            .append(`${e.operator == typescript_1.default.SyntaxKind.PlusPlusToken ? "++" : "--"}`, this.getCoordinates(e.getStart()));
    }
    transformPrefixUnaryExpression(node, toSection) {
        const e = node;
        if (e.operator === typescript_1.default.SyntaxKind.ExclamationToken) {
            // require boolean
            if (!this.isBooleanType(e.operand)) {
                throw new types_1.TranspileError(`\`${node.getText()}\` is not allowed, operand of \`!\` must be boolean type`, this.getRange(node));
            }
        }
        return toSection
            .append(`${this.toScryptUnary(e, e.operator)}`, this.getCoordinates(e.getStart()))
            .appendWith(this, toSec => this.transformExpression(e.operand, toSec));
    }
    transformCallExpression(node, toSection) {
        const e = node;
        if (e.expression.kind === typescript_1.default.SyntaxKind.PropertyAccessExpression) {
            // E.g. "str1.slice(2, 6)"
            return this.transformPropertyAccessCallExpression(e, toSection);
        }
        if (e.expression.kind === typescript_1.default.SyntaxKind.Identifier) {
            // E.g. "assert(...)"
            return this.transformIdentifierCallExpression(e, toSection);
        }
        return this.transformDefaultCallExpression(e, toSection);
    }
    transformBinaryOperation(operator, left, right, srcLoc, toSection, parenthesized = false) {
        if (parenthesized) {
            toSection.append('(', srcLoc);
        }
        toSection
            .appendWith(this, toSec => this.transformExpression(left, toSec))
            .append(` ${operator} `, srcLoc)
            .appendWith(this, toSec => this.transformExpression(right, toSec));
        if (parenthesized) {
            toSection.append(')', srcLoc);
        }
        return toSection;
    }
    transformPropertyAccessCallExpression(node, toSection) {
        const expr = node.expression;
        const name = expr.name.getText();
        const leftSide = expr.expression.getText();
        if (leftSide === "this") {
            if (name === 'checkSig') {
                return this.transformCallCheckSig(node, toSection);
            }
            if (name === 'checkMultiSig') {
                return this.transformCallCheckMultiSig(node, toSection);
            }
            if (name === 'checkPreimage' || name === 'checkPreimageSigHashType') {
                return this.transformCallCheckPreimage(node, toSection);
            }
            if (name === 'buildStateOutput') {
                if (this.getStatePropInfos().length === 0) {
                    throw new types_1.TranspileError(`Cannot access '${name}' method in a stateless contract, the contract must have at least one \`@Prop(true)\` property`, this.getRange(node));
                }
            }
            return this.transformDefaultCallExpression(node, toSection);
        }
        else if (leftSide === "Utils") {
            if (name === 'buildPublicKeyHashOutput' || name == 'buildAddressOutput') {
                return this.transformCallBuildPublicKeyHashOutput(node, toSection, name);
            }
            if (name === 'buildAddressScript') {
                return this.transformCallBuildAddressScript(node, toSection);
            }
            return this.transformDefaultCallExpression(node, toSection);
        }
        if (name === 'slice') {
            return this.transformCallSlice(node, toSection);
        }
        if (this.isCertainClassPropertyAccessExpr(expr, 'HashedMap')) {
            return this.transformSortedItemAccessTraceableCall(node, toSection, ['canGet', 'set', 'delete', 'has']);
        }
        if (this.isCertainClassPropertyAccessExpr(expr, 'HashedSet')) {
            return this.transformSortedItemAccessTraceableCall(node, toSection, ["add", "has", "delete"]);
        }
        return this.transformDefaultCallExpression(node, toSection);
    }
    transformIdentifierCallExpression(node, toSection) {
        const srcLoc = this.getCoordinates(node.getStart());
        let name = node.expression.getText();
        if (name === "assert") {
            return toSection
                .append("require(", srcLoc)
                .appendWith(this, toSec => this.transformExpression(node.arguments[0], toSec))
                .append(")");
        }
        if (name === "BigInt" || name === "Number") {
            toSection.append("(", srcLoc);
            node.arguments.forEach((arg) => {
                toSection.appendWith(this, toSec => this.transformExpression(arg, toSec));
            });
            return toSection.append(")");
        }
        if (name === 'and') {
            return this.transformBinaryOperation('&', node.arguments[0], node.arguments[1], srcLoc, toSection, true);
        }
        if (name === 'or') {
            return this.transformBinaryOperation('|', node.arguments[0], node.arguments[1], srcLoc, toSection, true);
        }
        if (name === 'xor') {
            return this.transformBinaryOperation('^', node.arguments[0], node.arguments[1], srcLoc, toSection, true);
        }
        if (name === 'invert') {
            return toSection
                .append('~', srcLoc)
                .appendWith(this, toSec => this.transformExpression(node.arguments[0], toSec));
        }
        if (name === 'lshift') {
            return this.transformBinaryOperation('<<', node.arguments[0], node.arguments[1], srcLoc, toSection, true);
        }
        if (name === 'rshift') {
            return this.transformBinaryOperation('>>', node.arguments[0], node.arguments[1], srcLoc, toSection, true);
        }
        if (name === 'equals') {
            return this.transformBinaryOperation('==', node.arguments[0], node.arguments[1], srcLoc, toSection);
        }
        if (name === 'toByteString') {
            let arg0 = node.arguments[0];
            if (arg0.kind !== typescript_1.default.SyntaxKind.StringLiteral) {
                throw new types_1.TranspileError('Only string literal can be passed to the first parameter of `toByteString`', this.getRange(node));
            }
            return toSection.appendWith(this, toSec => this.transformExpression(arg0, toSec));
        }
        if (name === 'PubKeyHash' || name === 'Addr') {
            return toSection
                .append("Ripemd160", srcLoc)
                .append("(")
                .appendWith(this, toSec => this.transformExpression(node.arguments[0], toSec))
                .append(")");
        }
        if (name === 'SigHashType') {
            return this.transformCallSigHashType(node, toSection);
        }
        if (name === 'reverseByteString') {
            toSection.append("reverseBytes(", srcLoc);
            node.arguments.forEach((arg, index) => {
                toSection
                    .appendWith(this, toSec => this.transformExpression(arg, toSec))
                    .append(index < node.arguments.length - 1 ? ", " : "");
            });
            return toSection.append(")");
        }
        if (name === 'int2ByteString') {
            // depending on whether `size` is passed, transpile using a different function
            let func = node.arguments.length === 1 ? 'pack' : 'num2bin';
            toSection.append(`${func}(`, srcLoc);
            node.arguments.forEach((arg, index) => {
                toSection
                    .appendWith(this, toSec => this.transformExpression(arg, toSec))
                    .append(index < node.arguments.length - 1 ? ", " : "");
            });
            return toSection.append(")");
        }
        if (name === 'byteString2Int') {
            toSection.append("unpack(", srcLoc);
            node.arguments.forEach((arg, index) => {
                toSection
                    .appendWith(this, toSec => this.transformExpression(arg, toSec))
                    .append(index < node.arguments.length - 1 ? ", " : "");
            });
            return toSection.append(")");
        }
        if (name === 'fill') {
            return this.transformCallFill(node, toSection);
        }
        if (name === 'slice') {
            return this.transformIdentifierCallSlice(node, toSection);
        }
        if (name === 'pubKey2Addr') {
            return toSection
                .append("hash160", srcLoc)
                .append("(")
                .appendWith(this, toSec => this.transformExpression(node.arguments[0], toSec))
                .append(")");
        }
        return this.transformDefaultCallExpression(node, toSection);
    }
    transformDefaultCallExpression(node, toSection) {
        const funcType = this._checker.getTypeAtLocation(node.expression);
        if (funcType.flags === typescript_1.default.TypeFlags.Any) {
            throw new types_1.TranspileError(`Calling function which returns \`any\` is not allowed`, this.getRange(node.expression));
        }
        const text = node.getText().replaceAll("?", "");
        switch (text) {
            case "this.ctx.serialize()":
                toSection
                    .append(`this.${InjectedCtxPreimageProp}`, this.getCoordinates(node.getStart()));
                break;
            case "this.insertCodeSeparator()":
                {
                    const ifStmt = Transpiler.getIfStatement(node);
                    if (ifStmt) {
                        throw new types_1.TranspileError(`insertCodeSeparator() cannot be called in a if statement`, this.getRange(node));
                    }
                    const md = Transpiler.getMethodDeclaration(node);
                    if (md) {
                        if (!Transpiler.isPublicMethod(md)) {
                            throw new types_1.TranspileError(`non-public methods cannot call insertCodeSeparator()`, this.getRange(node));
                        }
                        const methodInfo = this.findMethodInfo(md.name.getText());
                        if (methodInfo) {
                            methodInfo.codeSeparatorCount++;
                        }
                    }
                    toSection
                        .append(`***`, this.getCoordinates(node.getStart()));
                    toSection.skipNextAppend = true; // "***" is not closed using semicolon
                }
                break;
            default:
                toSection
                    .appendWith(this, toSec => this.transformExpression(node.expression, toSec))
                    .append("(")
                    .appendWith(this, toSec => {
                    const methodDec = funcType.symbol.declarations[0];
                    const inValidParams = methodDec.parameters.find(p => { var _a; return ((_a = p.type) === null || _a === void 0 ? void 0 : _a.getText()) === 'SmartContract'; });
                    if (inValidParams) {
                        throw new types_1.TranspileError(`Untransformable parameter: '${node.getText()}'`, this.getRange(node));
                    }
                    node.arguments.forEach((arg, index) => {
                        toSec
                            .appendWith(this, ts => this.transformExpression(arg, ts))
                            .append(index < node.arguments.length - 1 ? ", " : "");
                    });
                    return toSec;
                })
                    .append(")");
                break;
        }
        return toSection;
    }
    transformCallSlice(node, toSection) {
        // disable ByteString.slice()
        const msg = `\`${node.getText()}\` is not allowed here, use \`slice(ByteString, bigint, bigint)\` instead`;
        throw new types_1.TranspileError(msg, this.getRange(node));
    }
    transformIdentifierCallSlice(node, toSection) {
        toSection
            .appendWith(this, toSec => this.transformExpression(node.arguments[0], toSec))
            .append('[')
            .appendWith(this, toSec => this.transformExpression(node.arguments[1], toSec))
            .append(' : ');
        if (node.arguments.length === 3) {
            toSection.appendWith(this, toSec => this.transformExpression(node.arguments[2], toSec));
        }
        else {
            toSection
                .append('len(')
                .appendWith(this, toSec => this.transformExpression(node.arguments[0], toSec))
                .append(")");
        }
        return toSection.append("]");
    }
    transformCallTimeLock(node, toSection) {
        const arg = node.arguments[0];
        return toSection
            .append(`(SigHash.nSequence(${InjectedParamTxPreimage}) < 4294967295 && (`, this.getCoordinates(node.getStart()))
            .appendWith(this, toSec => this.transformExpression(arg, toSec))
            .append(`< 500000000 ? `)
            .append(`SigHash.nLocktime(${InjectedParamTxPreimage}) < 500000000 : true) && `)
            .append(`SigHash.nLocktime(${InjectedParamTxPreimage}) >= `)
            .appendWith(this, toSec => this.transformExpression(arg, toSec))
            .append(`)`);
    }
    transformCallCheckSig(node, toSection) {
        const srcLoc = this.getCoordinates(node.getStart());
        toSection.appendWith(this, toSec => {
            const _e = node.expression;
            return this.transformExpression(_e.name, toSec);
        });
        toSection.append("(", srcLoc);
        const args = node.arguments.slice(0, 2);
        args.forEach((arg, index) => {
            toSection
                .appendWith(this, toSec => this.transformExpression(arg, toSec))
                .append(index < args.length - 1 ? ", " : "");
        });
        return toSection.append(")", srcLoc);
    }
    transformCallCheckMultiSig(node, toSection) {
        const srcLoc = this.getCoordinates(node.getStart());
        toSection.appendWith(this, toSec => {
            const _e = node.expression;
            return this.transformExpression(_e.name, toSec);
        });
        toSection.append("(", srcLoc);
        const args = node.arguments.slice(0, 2);
        args.forEach((arg, index) => {
            toSection
                .appendWith(this, toSec => this.transformExpression(arg, toSec))
                .append(index < args.length - 1 ? ", " : "");
        });
        return toSection.append(")", srcLoc);
    }
    transformCallCheckPreimage(node, toSection) {
        const srcLoc = this.getCoordinates(node.getStart());
        toSection.appendWith(this, toSec => {
            const _e = node.expression;
            toSec.append("Tx.");
            return this.transformExpression(_e.name, toSec);
        });
        toSection.append("(", srcLoc);
        node.arguments.forEach((arg, index) => {
            toSection
                .appendWith(this, toSec => this.transformExpression(arg, toSec))
                .append(index < node.arguments.length - 1 ? ", " : "");
        });
        return toSection.append(")", srcLoc);
    }
    transformCallBuildPublicKeyHashOutput(node, toSection, name) {
        if (node.arguments.length !== 2) {
            throw new types_1.TranspileError(`Invalid arguments length for ${name}`, this.getRange(node));
        }
        return toSection
            .append(`Utils.buildOutput(Utils.buildPublicKeyHashScript(`, this.getCoordinates(node.getStart()))
            .appendWith(this, toSec => this.transformExpression(node.arguments[0], toSec))
            .append("), ")
            .appendWith(this, toSec => this.transformExpression(node.arguments[1], toSec))
            .append(")");
    }
    transformCallBuildAddressScript(node, toSection) {
        if (node.arguments.length !== 1) {
            throw new types_1.TranspileError(`Invalid arguments length for buildAddressScript`, this.getRange(node));
        }
        return toSection
            .append(`Utils.buildPublicKeyHashScript(`, this.getCoordinates(node.getStart()))
            .appendWith(this, toSec => this.transformExpression(node.arguments[0], toSec))
            .append(")");
    }
    transformCallFill(node, toSection) {
        const _length = node.arguments[1];
        const isCtc = this.isCtcExpression(_length);
        if (_length.kind !== typescript_1.default.SyntaxKind.NumericLiteral && !isCtc) {
            throw new types_1.TranspileError('Only compiled-time constant can be passed to the second parameter of `fill`', this.getRange(node));
        }
        return toSection
            .append("repeat(", this.getCoordinates(node.getStart()))
            .appendWith(this, toSec => this.transformExpression(node.arguments[0], toSec))
            .append(', ')
            .appendWith(this, toSec => (isCtc && !this.isParameterNode(node.arguments[1])) ? this.transformCtcExpr(_length, toSec) : this.transformExpression(_length, toSec))
            .append(')');
    }
    transformCallSigHashType(node, toSection) {
        return toSection
            .append("SigHashType", this.getCoordinates(node.getStart()))
            .append("(")
            .appendWith(this, toSec => {
            if (node.arguments[0].kind !== typescript_1.default.SyntaxKind.NumericLiteral) {
                throw new types_1.TranspileError(`Only support numeric literal: [65,66,67,193,194,195]`, this.getRange(node));
            }
            let n = node.arguments[0];
            const val = parseInt(n.getText());
            if ([65, 66, 67, 193, 194, 195].includes(val)) {
                return toSec.append(`b'${val.toString(16)}'`);
            }
            throw new types_1.TranspileError(`Only support numeric literal: [65,66,67,193,194,195]`, this.getRange(node));
        })
            .append(")");
    }
}
exports.Transpiler = Transpiler;
Transpiler.topCtcs = new Map();
Transpiler.abstractContractAst = new Map();
//# sourceMappingURL=transpiler.js.map