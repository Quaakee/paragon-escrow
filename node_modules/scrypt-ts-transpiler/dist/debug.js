"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatObjectFlags = exports.formatTypeFlags = exports.formatEnum = exports.compareValues = exports.stableSort = exports.indicesOf = void 0;
const typescript_1 = __importDefault(require("typescript"));
const enumMemberCache = new Map();
function selectIndex(_, i) {
    return i;
}
function indicesOf(array) {
    return array.map(selectIndex);
}
exports.indicesOf = indicesOf;
function stableSortIndices(array, indices, comparer) {
    // sort indices by value then position
    indices.sort((x, y) => comparer(array[x], array[y]) || compareValues(x, y));
}
/**
 * Stable sort of an array. Elements equal to each other maintain their relative position in the array.
 *
 * @internal
 */
function stableSort(array, comparer) {
    const indices = indicesOf(array);
    stableSortIndices(array, indices, comparer);
    return indices.map(i => array[i]);
}
exports.stableSort = stableSort;
function compareComparableValues(a, b) {
    return a === b ? 0 /* Comparison.EqualTo */ :
        a === undefined ? -1 /* Comparison.LessThan */ :
            b === undefined ? 1 /* Comparison.GreaterThan */ :
                a < b ? -1 /* Comparison.LessThan */ :
                    1 /* Comparison.GreaterThan */;
}
/**
 * Compare two numeric values for their order relative to each other.
 * To compare strings, use any of the `compareStrings` functions.
 *
 * @internal
 */
function compareValues(a, b) {
    return compareComparableValues(a, b);
}
exports.compareValues = compareValues;
function getEnumMembers(enumObject) {
    // Assuming enum objects do not change at runtime, we can cache the enum members list
    // to reuse later. This saves us from reconstructing this each and every time we call
    // a formatting function (which can be expensive for large enums like SyntaxKind).
    const existing = enumMemberCache.get(enumObject);
    if (existing) {
        return existing;
    }
    const result = [];
    for (const name in enumObject) {
        const value = enumObject[name];
        if (typeof value === "number") {
            result.push([value, name]);
        }
    }
    const sorted = stableSort(result, (x, y) => compareValues(x[0], y[0]));
    enumMemberCache.set(enumObject, sorted);
    return sorted;
}
function formatEnum(value = 0, enumObject, isFlags) {
    const members = getEnumMembers(enumObject);
    if (value === 0) {
        return members.length > 0 && members[0][0] === 0 ? members[0][1] : "0";
    }
    if (isFlags) {
        const result = [];
        let remainingFlags = value;
        for (const [enumValue, enumName] of members) {
            if (enumValue > value) {
                break;
            }
            if (enumValue !== 0 && enumValue & value) {
                result.push(enumName);
                remainingFlags &= ~enumValue;
            }
        }
        if (remainingFlags === 0) {
            return result.join("|");
        }
    }
    else {
        for (const [enumValue, enumName] of members) {
            if (enumValue === value) {
                return enumName;
            }
        }
    }
    return value.toString();
}
exports.formatEnum = formatEnum;
function formatTypeFlags(flags) {
    return formatEnum(flags, typescript_1.default.TypeFlags, /*isFlags*/ true);
}
exports.formatTypeFlags = formatTypeFlags;
function formatObjectFlags(flags) {
    return formatEnum(flags, typescript_1.default.ObjectFlags, /*isFlags*/ true);
}
exports.formatObjectFlags = formatObjectFlags;
//# sourceMappingURL=debug.js.map