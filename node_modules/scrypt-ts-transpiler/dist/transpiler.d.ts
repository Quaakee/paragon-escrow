import ts from 'typescript';
import { IndexerWriter } from './indexerWriter';
import { TranspileError } from './types';
/**
 * @ignore
 */
declare class EmittedLine {
    prefixTabs: number;
    code: string;
    currentCol: number;
    sourceMap: number[][];
    constructor(prefixTabs?: number, currentCol?: number, codeLines?: string, sourceMap?: any[]);
    copy(): EmittedLine;
    findByCol(col: number): number[];
}
/**
 * @ignore
 */
declare class EmittedSection {
    lines: EmittedLine[];
    errors: TranspileError[];
    skipNextAppend: boolean;
    constructor(initialLine?: EmittedLine);
    static join(...sections: EmittedSection[]): EmittedSection;
    getLastLine(): EmittedLine;
    getCode(): string;
    getSourceMap(): number[][][];
    append(code: string, srcLocation?: ts.LineAndCharacter): EmittedSection;
    appendWith(ctx: Transpiler, updater: (base: EmittedSection) => EmittedSection, increaseTab?: boolean): EmittedSection;
    private concat;
}
type CtxAccessInfo = {
    accessVersion: boolean;
    accessHashPrevouts: boolean;
    accessHashSequence: boolean;
    accessHashOutputs: boolean;
    accessLocktime: boolean;
    accessSequence: boolean;
    accessSigHashType: boolean;
    accessOutpoint: boolean;
    accessScriptCode: boolean;
    accessValue: boolean;
    accessSerialize: boolean;
};
type AccessInfo = {
    accessCtx: boolean;
    accessCtxInfo: CtxAccessInfo;
    accessChange: boolean;
    accessState: boolean;
    accessPrevouts: boolean;
    accessHashedProps: string[];
    accessTimelock: boolean;
};
type MethodInfo = {
    accessInfo: AccessInfo;
    isPublic: boolean;
    isBase: boolean;
    name: string;
    codeSeparatorCount: number;
};
type PropInfo = {
    name: string;
    isState: boolean;
    isBase: boolean;
    isStatic: boolean;
    isReadonly: boolean;
    isCTC: boolean;
    isHashed: boolean;
};
/**
 * @ignore
 */
export declare class Transpiler {
    static topCtcs: Map<string, string>;
    scComponents: ts.ClassDeclaration[];
    private methodInfos;
    private propInfos;
    private static abstractContractAst;
    _srcFile: ts.SourceFile;
    _host: ts.CompilerHost | undefined;
    _checker: ts.TypeChecker;
    _compilerOptions: ts.CompilerOptions;
    _scryptOutDir: string;
    _tsRootDir: string;
    _indexer: IndexerWriter;
    _localTypeSymbols: Map<string, ts.Symbol>;
    _importedTypeSymbols: Map<string, ts.Symbol>;
    _watch: boolean;
    _currentContract: ts.ClassDeclaration;
    _constructorParametersMap: Map<string, ts.Node>;
    constructor(sourceFile: ts.SourceFile, host: ts.CompilerHost | undefined, checker: ts.TypeChecker, tsRootDir: string, scryptOutDir: string, indexer: IndexerWriter, compilerOptions: ts.CompilerOptions);
    get ctxMethods(): string[];
    get _scryptRelativePath(): string;
    get _scryptFullPath(): string;
    get currentContractName(): string;
    get currentbaseContractName(): string;
    get currentbaseContract(): ts.ClassDeclaration;
    get _transformationResultRelativePath(): string;
    get _transformationResultFullPath(): string;
    get _sourceMapRelativePath(): string;
    get _sourceMapFullPath(): string;
    setLocalSymbols(localTypeSymbols: Map<string, ts.Symbol>): void;
    transform(allmissSym: Map<ts.SourceFile, Map<string, ts.Symbol>>): EmittedSection;
    isTransformable(): boolean;
    getSCComponents(): ts.ClassDeclaration[];
    isFromThirdParty(filepath: string): boolean;
    private outputScrypt;
    private outputTransformationResult;
    private diagnose;
    private outputDiagnostic;
    private checkTransformedScrypt;
    private compileError2transpileError;
    private outputSourceMapFile;
    private updateIndex;
    private isExtendsSCComponent;
    private isContract;
    private static getBaseContractName;
    private isInherited;
    private isTranspilingConstructor;
    private isTranspilingBaseContract;
    private isLibrary;
    /**
     * get relative path starting from `tsRootDir`
     * @param fullFilePath
     * @param ext extension of the path
     * @returns
     */
    private getRelativePathFromTsRoot;
    private getRelativePathFromArtifacts;
    private searchSmartContractComponents;
    private searchTopCtcs;
    private getCoordinates;
    private getRange;
    private getResolvedType;
    private findDeclarationFile;
    private transformProps;
    private checkPropsOverride;
    private checkMethodsOverride;
    private transformMethods;
    static create_ctx_function(ctxAccessInfo: CtxAccessInfo, section: EmittedSection): void;
    private transformClassDeclaration;
    private injectScryptProps;
    private injectScryptStructs;
    private transformPropertySignature;
    private transformPropertyDeclaration;
    private buildConstructorParametersMap;
    static accessSetConstructor(statements: ts.NodeArray<ts.Statement>): boolean;
    private checkSuperStmt;
    private checkSetConstructorStmt;
    private canBeImplicitConstructor;
    private transformConstructorBody;
    private transformConstructor;
    private transformMethodDeclaration;
    private isAssertStatement;
    private isBlockStatementAssert;
    private isForStatementAssert;
    private isIfStatementAssert;
    private isConsoleLogStatement;
    private verifyLastAssertStatement;
    private needAppendLastStatement;
    private hasPropertyAccessExpression;
    private hasFunctionCallExpression;
    private createMethodAccessInfo;
    private static pickAccessInfo;
    private initAllMethodInfos;
    private initAllPropInfos;
    createMethodInfo(m: ts.MethodDeclaration, currentMethodName: string, isBase: boolean): MethodInfo;
    createPropInfo(m: ts.PropertyDeclaration, isBase: boolean): PropInfo;
    private findMethodInfo;
    private getCtxMethodInfos;
    private findPropInfo;
    private getHashedPropInfos;
    private getStatePropInfos;
    private getPublicMethodCount;
    /**
     * does the current contract have a method to access CTX
     * @returns
     */
    private accessCtx;
    private accessTimelock;
    private getCtxAccessInfo;
    /**
   * does the current contract have a method to access Hasheded prop
   * @returns
   */
    private accessHashededProp;
    private accessStateProp;
    private accessChange;
    private accessPrevouts;
    private shouldAutoAppendChangeAmount;
    private shouldAutoAppendPrevouts;
    static isPublicMethod(node: ts.Node): boolean;
    private shouldAutoAppendSighashPreimage;
    private shouldAutoAppendAccessPaths;
    private transformParameter;
    private transformStatement;
    private transformExpression;
    private transformEnclosingTypeNode;
    private transformType;
    private saveSymbol;
    private transformModifiers;
    private static findDecorator;
    private static isProperty;
    private static isMethod;
    private isNonProp;
    private isStaticReadOnlyNonProp;
    private static isStateProperty;
    private static getClassDeclaration;
    private static getMethodDeclaration;
    private static getIfStatement;
    private findMethodDeclaration;
    private isNonPropReferences;
    private allPropertyDeclaration;
    private isCtcBinaryExpression;
    private isCtcPrefixUnaryExpression;
    private isCtcParenthesizedExpression;
    private isCtcExpression;
    private isCtcDeclaration;
    private isCtcIdentifierOrProperty;
    private isParameterNode;
    private evalCtcBinaryExpression;
    private evalCtcPrefixUnaryExpression;
    private evalCtcParenthesizedExpression;
    private evalCtcExpression;
    private getImportedCtcValue;
    private transformCtcExpr;
    private transformCtcNode;
    private queryPropertyInitializedInStmt;
    private hasProperties;
    private static isStaticProperty;
    private static isReadonlyProperty;
    private onlyHasStaticProperties;
    private hasConstructor;
    private getConstructor;
    private checkConstructor;
    private getImportedPath;
    private resolvePackageDir;
    private saveThirdPartySymbol;
    private saveLocalSymbol;
    private transformImports;
    private transformTypeLiteralAndInterfaces;
    private toScryptBinary;
    private toScryptUnary;
    private type2ResolvedName;
    private getResolvedTypeName;
    private isHashedMapOrHashedSet;
    private isCertainClassPropertyAccessExpr;
    private transformSortedItemAccessTraceableCall;
    private transformStringLiteralExpression;
    private transformBigIntLiteralExpression;
    private transformArrayLiteralExpression;
    private transformObjectLiteralExpression;
    private transformIdentifierExpression;
    private isBooleanType;
    private transformBinaryExpression;
    private transformSpecialPropertyAccessExpression;
    private transformCTCPropertyAccessExpression;
    private transformHashedPropertyAccessExpression;
    private transformPropertyAccessExpression;
    private transformArrowFunctionExpression;
    private transformNewExpression;
    private transformElementAccessExpression;
    private transformConditionalExpression;
    private transformParenthesizedExpression;
    private transformPostfixUnaryExpression;
    private transformPrefixUnaryExpression;
    private transformCallExpression;
    private transformBinaryOperation;
    private transformPropertyAccessCallExpression;
    private transformIdentifierCallExpression;
    private transformDefaultCallExpression;
    private transformCallSlice;
    private transformIdentifierCallSlice;
    private transformCallTimeLock;
    private transformCallCheckSig;
    private transformCallCheckMultiSig;
    private transformCallCheckPreimage;
    private transformCallBuildPublicKeyHashOutput;
    private transformCallBuildAddressScript;
    private transformCallFill;
    private transformCallSigHashType;
}
export {};
